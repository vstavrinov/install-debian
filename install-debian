#!/bin/bash

# Auto install Debian base system
# (C) Vladimir Stavrinov <vstavrinov@gmail.com>
# License: latest GPL at http://www.gnu.org/licenses/

#set -x -v

VERSION=2.2.19
if [ "$(id -u)" -ne 0 ]; then
    echo "
    Your should be root to run this script.
    "
    exit
fi

SELF_NAME=$(basename "$0")

unset ADDRESS || true
unset APT || true
unset APT_OPTIONS || true
unset ARCH || true
unset BOOT || true
unset DEVICE || true
unset CREATE || true
unset ARRAY || true
unset LEVEL || true
unset FS_TYPE || true
unset DOMAIN || true
unset GATEWAY || true
unset HOSTNAME
unset HOSTNAME || true
unset LOG || true
unset MAILTO || true
unset MIRROR || true
unset NAMESERVER || true
unset ORACLE_OWNER || true
unset PARTITION || true
unset ROOT || true
unset SUITE || true
unset TIMEZONE || true
unset TMP || true
unset USR || true
unset home || true
unset opt || true
unset srv || true
unset var || true

: "${LOG:=${SELF_NAME}.log}"

[ -r /etc/install-debian/default.conf ] && . /etc/install-debian/default.conf
[ -r /etc/install-debian/local.conf ] && . /etc/install-debian/local.conf


kernels_number=3
kernel_size=48
modules_size=384
loader_size=16
base_size=32

# Cylinder size
CS=$((512*63*255))


export DEBIAN_FRONTEND="noninteractive"
: "${APT:=aptitude}"

####################
## INIT VARIABLES ##
####################

init_variables ()
{
    [ -n "$VERBOSE" ] && echo "Init Variables start"
    CORE=/dev/md0
    RAID=/dev/md1
    GROUP=sys
    if [ -z "$DEVICE" ] && [ -z "$ARRAY" ]; then
        DEVICE=$(gawk '{
                if (SIZE < $3 &&
                    system("mdadm -D /dev/"$4" > /dev/null 2>&1")) {
                    SIZE=$3;
                    DEVICE=$4
                }
            }
            END {
                print DEVICE
            }
        ' /proc/partitions )
        SIZE=$(gawk -v DEVICE="${DEVICE//\//\\/}" '{
                    if ($4 == DEVICE) print $3
                    }' /proc/partitions)
        mapfile -t ARRAY < <(gawk -v SIZE="$SIZE" '{
                    if ($3 == SIZE) printf("%s\n", "/dev/"$4)
                    }' /proc/partitions)
        DEVICE=/dev/$DEVICE
        if [ ${#ARRAY[@]} -lt 2 ]; then
            CREATE=false
            unset ARRAY
        else
            CREATE=true
        fi
    elif [ -n "$DEVICE" ] && [ -z "${ARRAY[0]}" ]; then
        CREATE=false
    fi

    : "${PARTITION:=true}"
    : "${MIRROR:=$(awk '/^deb / {LN++; if (LN == 1) print $2}' \
        /etc/apt/sources.list)}"
    : "${ARCH:=$(dpkg --print-architecture )}"
    : "${SUITE:="stable"}"
    : "${FS_TYPE:=ext4}"
    : "${ROOT:=$base_size}"
    : "${BOOT:=$(((kernel_size*kernels_number+loader_size)*12/10))}"
    : "${TMP:=256}"
    : "${USR:=$((2048+(modules_size*kernels_number)*12/10))}"
    : "${var:=1024}"
    : "${home:=512}"
    : "${opt:=0}"
    : "${srv:=0}"
    LIMIT=400
    RATE=10
    BIOS=2
    EFI=1
    IFACE=$(ip route | awk '/default/ {print $NF}')
    : "${ADDRESS:=$(ip addr | awk "/inet .* $IFACE/ {print \$2}")}"
    : "${GATEWAY:=$(ip route  | awk '/^default via / {print $3}')}"
    : "${HOSTNAME:=$(hostname)}"
    : "${DOMAIN:=$(domainname -d)}"
    : "${DOMAIN:="oz"}"
    : "${NAMESERVER:=$(awk '/^[[:blank:]]*nameserver/ {print $2}' \
        /etc/resolv.conf | head -1)}"
    : "${MAILTO:=root@localhost}"
    : "${TIMEZONE:=$([ -f /etc/timezone ] && cat /etc/timezone)}"
    SHOW=false
    DEBUG=false
    NO_WARNING=false
    LOGGING=false
    TARGET="/mnt"
    DEBOOTSTRAP="debootstrap"
    #
    if [ "$ARCH" = "i386" ]; then
        if [ "$(free -g | awk '/^Mem: / {print $2}')" -ge 3 ]; then
            KERNEL="686-bigmem"
        else
            KERNEL="686"
        fi
    else
        KERNEL="$ARCH"
    fi
    [ -n "$VERBOSE" ] && echo "Init Variables finish"
} # init_variables

##################
## HELP MESSAGE ##
##################

usage ()
{
    echo "
    Auto install Debian base system

    $SELF_NAME [-lctpvdh] [-D DEVICE | -A ARRAY]  [-m MIRROR]
            [-R ROOT] [-U USR] [-B var] [-H home] [-O opt] [-S srv]
            [-I ADDRESS] [-G GATEWAY] [ -o BSOPT ]
            [-r LEVEL] [-x SPARE]
            [-N HOSTNAME] [-P DOMAIN] [-E NAMESERVER]
            [-T MAILTO] [-Z TIMEZONE] [-L LOG]

    -D DEVICE
        to install to [ $DEVICE ]
    -m MIRROR
        to install from [ $MIRROR ]
    -a ARCH
            Architecture [ $ARCH ]
    -c
        use cdebootstrap instead of debootstrap
    -t
        allow untrusted mirror
    -o BSOPT
        debootstrap extra options [ $BSOPT ]
    -A ARRAY
        quoted list of RAID components separated by space [ ${ARRAY[*]} ]
    -r LEVEL
        raid level (see mdadm)
    -x SPARE
        number of spare (eXtra) devices
    -K KERNEL
        Define kernel package as linux-image-KERNEL [ $KERNEL ]
    -u SUITE
        Distribution (suite) [ $SUITE ]
    -R ROOT
        / (root) partition size, Mb [ $ROOT ]
    -U USR
        /usr partition size, Mb [ $USR ]
    -B var
        /var partition size, Mb [ $var ]
    -H home
        /home partition size, Mb [ $home ]
    -O opt
        /opt partition size, Mb [ $opt ]
    -S srv
        /srv partition size, Mb [ $srv ]
    -I ADDRESS
        IP Adress/mask [ $ADDRESS ]
    -G GATEWAY
        Default Gateway [ $GATEWAY ]
    -N HOSTNAME
        Host Name [ $HOSTNAME ]
    -P DOMAIN
        Domain [ $DOMAIN ]
    -E NAMESERVER
        DNS address [ $NAMESERVER ]
    -T MAILTO
        Email address to send password to [ $MAILTO ]
    -Z TIMEZONE
        Time Zone [ $TIMEZONE ]
    -L LOG
        Log file to output to [ $LOG ]
    -l
        Logging output to file [ $LOG ]
    -p
        Manual partition and mount under $TARGET before install
    -e
        Clean space and exit.
    -n
        No warning dialog. Start immediately non-interactive.
    -s
        Do nothing, but Show variables values only. Strongly recommended for
        using before doing anything else.
    -V
        Version
    -v
        Verbose
    -d
        Debug
    -h
        Help

    Files:
        /etc/$SELF_NAME/$SELF_NAME.conf
            System wide config
        /etc/$SELF_NAME/local.conf
            Local config, override system settings
        /etc/$SELF_NAME/install/
            Everything from this directory will be copied to the root of new \
            system as related path
    "
    exit
} # usage ()

get_options ()

#############################
## GET COMMAND LINE OPIONS ##
#############################

{
    [ -n "$VERBOSE" ] && echo "Get Options start"
    EXCLUSIVE=false
    OPTERR=0
    while getopts D:A:r:x:m:a:o:K:u:R:U:B:H:N:O:S:I:M:G:P:E:T:Z:L:Vltpenscvdh \
        OPTION; do
        case $OPTION in
        D)
            $EXCLUSIVE && {
                echo "Options -D & -A are mutually exclusive";
                exit 1
            }
            EXCLUSIVE=true
            DEVICE=$OPTARG
            CREATE=false
            unset ARRAY
            ;;
        A)
            $EXCLUSIVE && {
                echo "Options -A & -D are mutually exclusive";
                exit 1
            }
            EXCLUSIVE=true
            mapfile -t -d " " ARRAY <<< "$OPTARG"
            DEVICE=${ARRAY[0]}
            CREATE=true
            ;;
        r)
            LEVEL=$OPTARG
            ;;
        x)
            SPARE=$OPTARG
            ;;
        m)
            MIRROR=$OPTARG
            ;;
        a)
            ARCH=$OPTARG
            ;;
        o)
            mapfile -t -d " " BSOPT <<< "$OPTARG"
            ;;
        c)
            DEBOOTSTRAP=cdebootstrap
            ;;
        t)
            if [ "$APT" = "apt-get" ]; then
                echo "Option '-t' require APT=aptitude"
                exit 1
            else
                APT_OPTIONS="$APT_OPTIONS --allow-untrusted"
            fi
            BSOPT+=('--no-check-gpg')
            ;;
        K)
            KERNEL=$OPTARG
            ;;
        u)
            SUITE=$OPTARG
            ;;
        R)
            ROOT=$OPTARG
            ;;
        U)
            USR=$OPTARG
            ;;
        B)
            var=$OPTARG
            ;;
        H)
            home=$OPTARG
            ;;
        O)
            opt=$OPTARG
            ;;
        S)
            srv=$OPTARG
            ;;
        I)
            ADDRESS=$OPTARG
            ;;
        G)
            GATEWAY=$OPTARG
            ;;
        N)
            HOSTNAME=$OPTARG
            ;;
        P)
            DOMAIN=$OPTARG
            ;;
        E)
            NAMESERVER=$OPTARG
            ;;
        T)
            MAILTO=$OPTARG
            ;;
        Z)
            TIMEZONE=$OPTARG
            ;;
        L)
            LOG=$OPTARG
            ;;
        l)
            LOGGING=true
            ;;
        p)
            PARTITION=false
            CREATE=false
            unset ARRAY
            # Find whole disk with root partition by striping out partition number and preceding 'p'
            DEVICE=$(mount |
                gawk -v TARGET=$TARGET '{
                        if ($3 == TARGET)
                        print gensub("(([0-9])p)?[0-9]+$", "\\2", 1, $1)
                    }')
            ;;
        e)
            ACTION=clean
            ;;
        n)
            NO_WARNING=true
            ;;
        s)
            SHOW=true
            ;;
        V)
            if [ -z "$VERBOSE" ]; then
                echo "
                $SELF_NAME $VERSION
                "
            else
                echo "
                $SELF_NAME $VERSION
                Auto install Debian base system
                (C) Vladimir Stavrinov <vstavrinov@gmail.com>
                "
            fi
            exit
            ;;
        v)
            VERBOSE="-v"
            ;;
        d)
            set -x -v
            DEBUG=true
            ;;
        h|*)
            usage
            ;;
        esac
    done
    shift  $((OPTIND - 1))
    if $SHOW; then
        show_var
        exit
    fi
    [ -n "$VERBOSE" ] && echo "Get Options finish."
} # get_options ()

set_logging ()
{
    if ${LOGGING} && $NO_WARNING; then
        [ -f "${LOG}" ] && rm -f "${LOG}"
        exec < /dev/null >> "${LOG}" 2>&1
    fi
} # set_logging

set_raid_level ()
{
    [ -n "$VERBOSE" ] && echo "Set RAID start."
    if [ -n "${ARRAY[0]}" ]; then
        : "${SPARE:=$((${#ARRAY[@]}%2))}"
        if [ -z "$LEVEL" ] && [ $((${#ARRAY[@]} - SPARE)) -eq 2 ]; then
            LEVEL=mirror
        else
            : ${LEVEL:=raid10}
        fi
    fi

    case $LEVEL in
        1|raid1)
        LEVEL=mirror
        ;;
    esac
    if [ ${#ARRAY[@]} -lt 2 ] || [ "$LEVEL" = "mirror" ]; then
        STRIPE=false
    else
        STRIPE=true
    fi
    [ -n "$VERBOSE" ] && echo "Set RAID finish."
} # set_raid_level

check_utils ()
{
    [ -n "$VERBOSE" ] && echo "Check Utils start."
    UTILS="
    mdadm
    grub-install
    tar
    gawk
    cp
    debootstrap
    fdisk
    basename
    dumpe2fs
    umount
    mount
    mkswap
    mkfs
    vgdisplay
    lvcreate
    vgcreate
    pvcreate
    parted
    yes
    partx
    sort
    dmraid
    pvremove
    pvs
    $APT
    dpkg
    free
    gawk
    pr
    xargs
    find
    chroot
    dialog
    mkdir
    vgs
    vgremove
    "

    for prog in $UTILS; do
        if ! type "$prog" > /dev/null; then
            echo "
            $prog not found.
            You MUST have all of those uitls to be installed:
            "
            echo "$UTILS"
            echo "
            Exiting ...
            "
            exit
        fi
    done
    [ -n "$VERBOSE" ] && echo "Check Utils finish."
} # check_utils

space_cutting ()
{
    ####################################
    ## CALCULATE DISK PARTITIONS SIZE ##
    ####################################
    [ -n "$VERBOSE" ] && echo "Space Cutting start."
    if $PARTITION; then
        if ! [ -b "$DEVICE" ]; then
            echo "There are no such block device $DEVICE". Exiting ...
            exit 1
        fi

        DISK=$(awk "{
            if (\"${DEVICE#/dev/}\" == \$NF) print int(\$(NF-1)/1024)
            }" /proc/partitions)

        $STRIPE && DISK=$((DISK*(${#ARRAY[@]}/2)))

        if [ -z "$DISK" ]; then
            echo "$DEVICE: no such device. Specify other one."
            exit
        fi

        RAM=$(free -m | gawk '/^Mem:/ {print $2}')
        case 0 in
            $([ "$RAM" -gt 4096 ]; echo $?))
            SWAP=4096
            ;;

            $([ "$RAM" -lt 2048 ]; echo $?))
            SWAP=2047
            ;;

            *)
            SWAP=$RAM
            ;;
        esac
        VOLUME=$((USR +
                    TMP +
                    ROOT +
                    SWAP +
                    home +
                    opt +
                    srv +
                    var))

        if [ $DISK -lt $VOLUME ]; then
            SWAP=10
            VOLUME=$((USR +
                        TMP +
                        ROOT +
                        SWAP +
                        home +
                        opt +
                        srv +
                        var))

        fi
        if ! $STRIPE; then
            RESERVE=$((DISK*RATE/100))
            [ $RESERVE -lt $LIMIT ] && RESERVE=$LIMIT
            EXTENT=$((DISK-RESERVE))
        else
            EXTENT=$((DISK-BOOT))
            :
        fi

        var=$((VOLUME -
                USR -
                ROOT -
                TMP -
                SWAP -
                home -
                opt -
                srv))


        # Check device if it is dmaraid mdadm to install it, 

        if dmraid -s "$(basename "$DEVICE")" 2>/dev/null; then
            DMRAID="dmraid"
        elif mdadm -D "$DEVICE" || [ ${#ARRAY[@]} -gt 1 ]; then
            MDADM="mdadm"
            :
        fi

    fi # if $PARTITION; then
    [ -n "$VERBOSE" ] && echo "Space Cutting start."
} # space_cutting ()

show_var ()
{
    ######################
    ## OUTPUT VARIABLES ##
    ######################

    echo " APT=$APT
    APT_OPTIONS=$APT_OPTIONS
    VERBOSE=$VERBOSE
    MIRROR=$MIRROR
    ARCH=$ARCH
    KERNEL=$KERNEL
    SUITE=$SUITE
    DEVICE=$DEVICE
    LEVEL=$LEVEL
    SPARE=$SPARE
    CREATE=$CREATE
    PARTITION=$PARTITION
    BOOT=$BOOT
    ROOT=$ROOT
    USR=$USR
    TMP=$TMP
    SWAP=$SWAP
    var=$var
    home=$home
    opt=$opt
    srv=$srv
    DISK=$DISK
    EXTENT=$EXTENT
    VOLUME=$VOLUME
    RESERVE=$RESERVE
    ADDRESS=${ADDRESS}
    GATEWAY=${GATEWAY}
    NAMESERVER=${NAMESERVER}
    HOSTNAME=${HOSTNAME}
    DOMAIN=${DOMAIN}
    TIMEZONE=${TIMEZONE}
    MAILTO=$MAILTO
    LOG=$LOG " |
    pr -J -w 78 -t --columns=2 |
    gawk '{printf(" %-39s %-39s\n", $1, $2)}'
    echo " ARRAY=(${ARRAY[*]})"
} # show_var ()

mb_to_cyl ()
{
    echo $((($1*1024*1024)/CS))
}

chrooted_procs ()
{
    echo Remaining chrooted procs ...
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET -exec file {} + 2>/dev/null |
    grep -E "[0-9]" && [ $((--LOOP)) -gt 0 ]
}

umount_target ()
{
    [ -n "$VERBOSE" ] && echo "Umount Target start."
    LOOP=3
    echo Finding chrooted procs ...
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET -exec file {} + 2>/dev/null
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET 2>/dev/null |
    grep -Eo "[0-9]+" |
    xargs -r ps wwu
    while chrooted_procs; do
        echo Killing chrooted procs ...
        find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET 2>/dev/null |
        grep -Eo "[0-9]+" |
        if
            [ $((--LOOP)) -eq 1 ]
        then
            xargs -r kill -9
        else
            xargs -r kill
        fi
    done
    awk "/${TARGET//\//\\/}/ {print \$2}" /proc/mounts |
    sort -r |
    uniq |
    xargs -r umount $VERBOSE -l
    [ -n "$VERBOSE" ] && echo "Umount Target finish."
} # umount_target ()

check_space ()
{
    [ -n "$VERBOSE" ] && echo "Check Space start."
    if [ $VOLUME -gt $EXTENT ] && $PARTITION; then
        echo "
        Disk is too small. Disk size should be more then $((VOLUME+RESERVE))
        Mb. Can not proceed. Adjust partition's size or do partitioning manual
        and use -p option.
        "
        show_var
        echo "
        Exiting ...
        "
        exit

    fi
    [ -n "$VERBOSE" ] && echo "Check Space finish."
} # check_space ()

start_warning ()
{
    if ! $NO_WARNING; then
        WIDTH=${COLUMNS:=75}
        if [ -n "$VERBOSE" ]; then
            VARS="$(show_var)"
            HEIGHT=$(($(echo "$VARS" | wc -l)+13))
        else
            VARS=""
            HEIGHT=15
        fi
        dialog --colors --no-collapse --defaultno --yesno " \Zb\Z4Install \
            Debain GNU/Linux\Zn\ZB

$VARS

    \Zb\Z1WARNING!\Zn\ZB This will destroy all data on the hard disks:

    \Zb\Z5$(if [ ${#ARRAY[@]} -gt 1 ]; then echo "${ARRAY[@]}"; else \
        echo "$DEVICE"; fi)\Zn\ZB

    Are Your sure to continue?  " $HEIGHT $WIDTH || exit
    fi
} # start_warning ()

start_head ()
{
    echo "
    Starting with parameters:
    "
    show_var

    echo "
    --=== Starting $(basename "$0") at $(date), elapsed $SECONDS seconds. ===--
    "
    [ -d $TARGET ] || mkdir $VERBOSE $TARGET
} # start_head ()


clean_space ()
{
    echo "Clean Space start"
    if $PARTITION; then

        umount_target
        invoke-rc.d lvm2 restart

        lvs --noheadings -o vg_name,lv_name $GROUP |
        while read -r VG LV; do
            lvremove $VERBOSE -f -f "${VG}"/"${LV}"
        done

        vgs --noheadings -o vg_name $GROUP |
        while read -r VG; do
            vgremove $VERBOSE -f -f "$VG"
        done

        pvs --noheadings -o pv_name "${DEVICE}"* ${CORE}* ${RAID}* \
            "$(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\1*/g')" |
        while read -r PV; do
            pvremove $VERBOSE -f -f "$PV"
        done
        if { [ -z "$MDADM" ] &&
            grep -q "${DEVICE#/dev/}" /proc/mdstat; } ||
            $CREATE; then
            invoke-rc.d mdadm-raid stop
            mdadm $VERBOSE -E "$DEVICE" &&
            mdadm $VERBOSE --zero-superblock "$DEVICE"
        fi
        # stop raid 
        mdadm -D $CORE $VERBOSE  && mdadm -S $CORE $VERBOSE
        mdadm -D "$DEVICE" $VERBOSE && mdadm -S "$DEVICE" $VERBOSE
        mdadm -D $RAID $VERBOSE && mdadm -S $RAID $VERBOSE
        # remove partitions
        for MEMBER in ${DEVICE} "${ARRAY[@]}"; do
            mdadm $VERBOSE -E "${MEMBER}" &&
            mdadm $VERBOSE --zero-superblock "${MEMBER}"
            # To insure there are no file system do wipe first 4 sectors on
            # every partition
            for BLOCK in "$MEMBER"?*; do
                mdadm $VERBOSE -E "${BLOCK}" &&
                mdadm $VERBOSE --zero-superblock "${BLOCK}"
                echo "Wipe $BLOCK"
                dd if=/dev/zero of="$BLOCK" count=4
            done
            parted -sm "$MEMBER" mklabel gpt
            sleep 1
            partx -d "$MEMBER"
            parted -sm "$MEMBER" print |
            awk -F: '/^[0-9]+:/ {print $1}' |
            while read -r POINT; do
                parted -s "$MEMBER" rm "$POINT"
                rm -f "${MEMBER}""${POINT}"
            done
            partx -d "$MEMBER"
            # To insure there are no partition table, do wipe first 4
            # sectors on every disk
            mdadm $VERBOSE -E "${MEMBER}" &&
            mdadm $VERBOSE --zero-superblock "${MEMBER}"
            dd if=/dev/zero of="$MEMBER" count=512
        done
    fi # if $PARTITION
    echo "Clean Space finish"
    [ "$ACTION" = "claen" ] && exit
}

create_space ()
{
    #######################################################
    # PREPARE TARGET TO INSTALL TO: PARTITIONING IF NEED ##
    # AND CREATING FSTAB                                 ##
    #######################################################
    if $PARTITION; then
        ###############################
        ## PARTITIONING ENITIRE DISK ##
        ###############################
        # create single mirror array
        if ! $STRIPE; then
            if $CREATE; then
                echo yes |
                mdadm -C $CORE -e 0 -x $SPARE -a part \
                    -n $((${#ARRAY[@]}-SPARE)) \
                    -l mirror $VERBOSE "${ARRAY[@]}"
                DEVICE=$CORE
            fi
            POOL=("$DEVICE")
        else
            mapfile -t -d " " POOL <<< "${ARRAY[@]}"
        fi
        PART="${DEVICE/$PART%*[0-9_]/${DEVICE}p}"

        ###############################################
        ## CALCULATE PARTITIONS BORDERS BY CYLINDERS ##
        ###############################################

        # partitioning
        for MEMBER in ${POOL[@]}; do
            [ -n "$VERBOSE" ] && echo Start partitioning  "$MEMBER"  ...
            if ! $STRIPE; then
                extent_size=$(mb_to_cyl $EXTENT)
                extent_end=$((BIOS+EFI+extent_size))
                parted "$MEMBER" <<-PARTED
                    mklabel gpt
                    unit cyl
                    mkpart primary ext2 0 $BIOS
                    set 1 bios_grub on
                    mkpart primary fat32 $BIOS $((BIOS+EFI))
                    mkpart primary ext2 $((BIOS+EFI)) $extent_end
                    set 2 boot on
                    quit
PARTED
            else
                parted -s "$MEMBER" mklabel gpt
                boot_size=$(mb_to_cyl $BOOT)
                boot_end=$((BIOS+EFI+boot_size))
                extent_end=$(parted -sm $DEVICE unit cyl print |
                    awk -F: -v NODE=$DEVICE '{
                        if ($1 == NODE) print gensub("cyl", "", 1, $2)
                        }')
                parted "$MEMBER" <<-PARTED
                    mklabel gpt
                    unit cyl
                    mkpart primary ext2 0 $BIOS
                    set 1 bios_grub on
                    mkpart primary fat32 $BIOS $((BIOS+EFI))
                    mkpart primary ext2 $((BIOS+EFI)) $boot_end
                    set 2 boot on
                    mkpart primary ext2 $boot_end  $extent_end
                    quit
PARTED
                sleep 1
                partx -a "$MEMBER"
                for BLOCK in "$MEMBER"?*; do
                    mdadm $VERBOSE -E "${BLOCK}" &&
                    mdadm $VERBOSE --zero-superblock "${BLOCK}"
                    echo "Wipe $BLOCK"
                    #dd if=/dev/zero of=$BLOCK count=512
                done
            fi
            [ -n "$VERBOSE" ] && echo Finish partitioning  "$MEMBER"  ...
        done # for MEMBER in ${POOL[@]}; do

        # create double raid arrays
        if $STRIPE && $CREATE; then
            echo yes |
            mdadm -C $CORE -x $SPARE -a md \
                -n $((${#ARRAY[@]}-SPARE)) \
                -l mirror $VERBOSE \
                $(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\13/g')
            DEVICE=$CORE
            mdadm -C $RAID -x $SPARE -a md \
                -n $((${#ARRAY[@]}-SPARE)) \
                -l $LEVEL $VERBOSE \
                $(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\14/g')
        fi

        ############################
        ## CREATE LOGICAL VOLUMES ##
        ############################

        # If disk device name end with number (mdadm is case), then append 'p'
        # to further use it in partition device name.

        if ! $STRIPE; then
            sleep 2
            pvcreate -f -f -y $VERBOSE ${PART}3 || exit
            vgcreate $VERBOSE $GROUP ${PART}3
            lvcreate $VERBOSE -y -L ${BOOT} -n boot $GROUP
        else
            pvcreate -f -f -y $VERBOSE $RAID || exit
            vgcreate $VERBOSE $GROUP $RAID
        fi
        lvcreate $VERBOSE -y -L "${ROOT}" -n apex $GROUP
        lvcreate $VERBOSE -y -L "${USR}" -n usr $GROUP
        lvcreate $VERBOSE -y -L ${SWAP} -n swp $GROUP
        lvcreate $VERBOSE -y -L ${TMP} -n tmp $GROUP

        for VOL in var home opt srv; do
            EXTENT=$(vgdisplay -c $GROUP | gawk -F: '{print $13*$16}')
            eval SIZE=\$${VOL}
            [ $((SIZE*1024)) -gt "$EXTENT" ] && SIZE=$((EXTENT/1024))
            [ $SIZE -gt 0 ] && lvcreate $VERBOSE -y -L ${SIZE} -n $VOL $GROUP
        done
        if ! $STRIPE; then
            mkfs.vfat $VERBOSE ${PART}2
        else
            mkfs $VERBOSE -L boot -t $FS_TYPE $CORE
        fi
        for POINT in /dev/"$GROUP"/*; do
            mkfs $VERBOSE -L "$(basename "$POINT")" -t $FS_TYPE "$POINT"
        done

        ######################################
        ## MOUNT ALL PARTITIONS AND VOLUMES ##
        ######################################

        mkswap /dev/$GROUP/swp
        ROOT_DEVICE=/dev/$GROUP/apex
        mount $VERBOSE $ROOT_DEVICE "${TARGET}"
        for POINT in boot usr tmp var home opt srv; do
            [ -d "${TARGET}/${POINT}" ] ||
            mkdir $VERBOSE "${TARGET}/${POINT}"
        done
        if ! $STRIPE; then
            mount $VERBOSE /dev/$GROUP/boot "${TARGET}/boot"
            mkdir "${TARGET}/boot/efi"
            mount $VERBOSE ${PART}2 "${TARGET}/boot/efi"
        else
            mount $VERBOSE $CORE "${TARGET}/boot"
        fi
        ###################
        ## PREPARE FSTAB ##
        ###################

        FSTAB="proc /proc  proc defaults 0 0
        /dev/$GROUP/apex / $FS_TYPE defaults 0 1"
        # Add root (/) & boot records depends on raid level to fstab
        if $STRIPE; then
            FSTAB="${FSTAB}
            $CORE /boot $FS_TYPE defaults 0 2"
        fi
        for POINT in /dev/"$GROUP"/*; do
            if [ -d "${TARGET}/$(basename "${POINT}")" ]; then
                mount $VERBOSE "$POINT" ${TARGET}/"$(basename "${POINT}")"
                FSTAB="${FSTAB}
        $POINT /$(basename "${POINT}" ) $FS_TYPE defaults 0 2"
            fi
        done
        FSTAB="${FSTAB}
        /dev/$GROUP/swp none swap sw 0 0"
    else # if $PARTITION
        PART="${DEVICE/$PART%*[0-9_]/${DEVICE}p}"
        FSTAB="proc /proc  proc defaults 0 0 $(echo
        mount |
        gawk -v TARGET=$TARGET '{
            if ($3 ~ TARGET) {
                gsub(TARGET,"", $3)
                "blkid -s UUID -o value "$1"" | getline UUID
                if ($3 == "") {
                    gsub("","/",$3)
                    print "UUID="UUID, $3, $5, "defaults,errors=remount-ro 0 1"
                } else {
                    print "UUID="UUID, $3, $5, "defaults 0 2"
                }
            }
        }'
        # gawk '/partition/ {print $1, "none swap sw 0 0"}' /proc/swaps
        parted -sm $DEVICE print |
        awk -F: -v PART=$PART '/swap/ {print PART$1, "none swap sw 0 0"}'
        )"
        ROOT_DEVICE=$(
            awk -v TARGET=$TARGET '{if ($2 == TARGET) print $1}' /proc/mounts)
    fi # if $PARTITION
} # create_space ()

install_base_system ()
{
    FSTAB="${FSTAB}
    sysfs  /sys     sysfs    defaults                         0 0
    udev   /dev     devtmpfs defaults                         0 0
    devpts /dev/pts devpts   \
        rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0"

    #########################
    ## INSTALL BASE SYSTEM ##
    #########################

    echo "Installing Base System ..."
    if ! $DEBOOTSTRAP ${VERBOSE:+--verbose} "${BSOPT[@]}" --arch="$ARCH" "$SUITE" $TARGET "$MIRROR"; then
        echo "Base System installation failed. Exiting ..."
        exit 1
    fi
} # install_base_system () 

configure_system ()
{
    ########################
    ## MAIN CONFIGURATION ##
    ########################

    echo "$FSTAB" |
    column -t > ${TARGET}/etc/fstab

    echo "
    auto lo $IFACE

    iface lo inet loopback

    iface $IFACE inet static
        address $ADDRESS
        gateway $GATEWAY

    " > ${TARGET}/etc/network/interfaces

    echo "$HOSTNAME
    " > ${TARGET}/etc/hostname

    echo "
    127.0.0.1 localhost
    ${ADDRESS%/*} ${HOSTNAME}.${DOMAIN} ${HOSTNAME}
    " > ${TARGET}/etc/hosts

    echo "
    nameserver $NAMESERVER
    search $DOMAIN
    " |
    column -t > ${TARGET}/etc/resolv.conf

    echo "
    deb $MIRROR $SUITE main contrib non-free
    #deb $MIRROR unstable main contrib non-free
    #deb $MIRROR testing main contrib non-free
    #deb $MIRROR stable main contrib non-free
    " |
    column -t > ${TARGET}/etc/apt/sources.list

    cp $VERBOSE -a ${TARGET}/etc/profile{,.dpkg-dist}

    echo "
    do_symlinks = No
    do_initrd = Yes
    do_bootloader = no
    do_bootfloppy = no
    postinst_hook = update-grub
    postrm_hook   = update-grub
    " |
    column -t > ${TARGET}/etc/kernel-img.conf

    echo "$TIMEZONE" > ${TARGET}/etc/timezone
    cp $VERBOSE ${TARGET}/usr/share/zoneinfo/"$TIMEZONE" ${TARGET}/etc/localtime

    if type -p rpg; then
        PASSWORD=$(rpg -r 1 -m 6 -x 10 | tr -d " \n")
    elif type -p apg; then
        PASSWORD=$(apg -MCNL -n 1 -m 6 -x 10)
    else
        HEAP=(b d f k m n p r s t v z e u a i
            B D F K M N P R S T V Z E U A I
            2 3 4 5 6 7 8 9)
        for _ in $(seq $((6+RANDOM % 4))); do
            PASSWORD=${PASSWORD}$(
                printf "%s" "${HEAP[$((RANDOM % ${#HEAP[@]}))]}")
        done
    fi
    [ -z "$PASSWORD" ] &&
    PASSWORD=${HOSTNAME}
} # configure_system ()

install_packages ()
{
    #########################################
    ## INSTALL AND CONFIGURE MAIN PACKAGES ##
    #########################################

    ATTACHMENTS="
    /etc/Muttrc.d/local.rc 644
    /etc/X11/Xresources/x11-local 644
    /etc/apt/apt.conf.d/cache 644
    /etc/grub.d/06_local_theme 755
    /etc/init.d/iptables 755
    /etc/lynx-cur/local.cfg 644
    /etc/network/inactive 600
    /etc/network/iptables 600
    /etc/profile.d/local.sh 644
    /etc/skel/.lynxrc 644
    /etc/vim/vimrc.local 644
    /root/.muttrc 644
    /usr/lib/cgi-bin/quote 755
    /var/www/index.shtml 644
    "
    echo "
        Extracting attached files ...
    "
    echo "$ATTACHMENTS" | grep -v '^$' |
    while read -r FILE MODE; do
        [ -d "$(dirname ${TARGET}"$FILE")" ] ||
        mkdir $VERBOSE -p "$(dirname ${TARGET}"$FILE")"
        sed -e "
            1,\%^###  BEGIN $FILE  ###$%d
            \%^###  END $FILE  ###$%,\$d
        " "$0" >> ${TARGET}"$FILE"
        chmod $VERBOSE "$MODE" ${TARGET}"$FILE"
        ls -l ${TARGET}"$FILE"
    done

    if [ -e /sys/firmware/efi ]; then
        GRUB=grub-efi
    else
        GRUB=grub-pc
    fi

    # make udev db available in chroot for lvm used by grub
    mkdir ${TARGET}/run/udev
    mount --bind /run/udev ${TARGET}/run/udev

    chroot ${TARGET} su - <<-EOF
    eval  $DEBUG && set -x -v
    if ! [ -d /run/lock ]; then
        mkdir $VERBOSE -p /run/lock
        chmod $VERBOSE ugo+wt /run/lock
    fi

    mount $VERBOSE /proc
    mount $VERBOSE /sys
    mount $VERBOSE /dev
    mount $VERBOSE /dev/pts

    MAIN_LIST="
    grub-pc-bin
    $GRUB
    lvm2
    gawk
    parted
    dosfstools
    $DMRAID
    $MDADM
    sudo
    vim
    less
    mutt
    lynx
    ftp
    file
    lsof
    ssh
    screen
    exim4
    mailutils
    fortunes
    fortunes-ru
    grub-splashimages
    grub2-splashimages
    host
    procinfo
    pciutils
    usbutils
    lsscsi
    scsitools
    ntp
    lsof
    ethtool
    mtr
    nmap
    lsb-release
    linux-image-$KERNEL
    \$(apt-cache search ^firmware- | awk  '{print \$1}')
    "

    # Set non-interactive mode
    export DEBIAN_FRONTEND="noninteractive"
    #export DEBIAN_NOWARNINGS="yes"
    #export DEBCONF_PRIORITY="critical"

    #echo -e \\\\t |
    if type -p aptitude; then
        APT=$APT
    else
        APT=apt-get
    fi
    if [ "\$APT" = "aptitude" ]; then
        \$APT $VERBOSE $APT_OPTIONS -y update
        \$APT $VERBOSE $APT_OPTIONS -y install \$MAIN_LIST
    else
        \$APT $APT_OPTIONS -y update
        \$APT $APT_OPTIONS -y install \$MAIN_LIST
    fi

    cd /bin
    ln $VERBOSE -sf bash sh
    cd -

    /etc/init.d/exim4 stop
    /etc/init.d/ssh stop

    echo "$HOSTNAME ALL=(ALL)NOPASSWD: ALL" >> /etc/sudoers

    sed -i 's/BOOTLOGD_ENABLE=No/BOOTLOGD_ENABLE=Yes/' /etc/default/bootlogd
    sed -i 's/UTC=.*/UTC=no/' /etc/default/rcS

    ln $VERBOSE -s /usr/games/fortune /usr/bin

    update-alternatives --set editor /usr/bin/vim.basic

    cp  $VERBOSE -a /etc/Muttrc.d/colors.rc{,.dpkg-dist}
    sed -e 's/^\([^#]\+\)/#\1/' \
        -e 's/#.*\<color\>.*\<normal\>.*/color normal default default/' \
        -i /etc/Muttrc.d/colors.rc

    echo "# vim: filetype=muttrc:" >> /etc/Muttrc.d/colors.rc

    cp $VERBOSE -a  /etc/lynx-cur/lynx.lss{,.dpkg-dist}
    sed -i 's/\\(^normal:\|^default:\\)/#\\1/' /etc/lynx-cur/lynx.lss
    cp $VERBOSE -a /etc/lynx-cur/lynx.cfg{,.dpkg-dist}
    sed -i 's/^#\\(ENABLE_LYNXRC:\\)/\\1/' /etc/lynx-cur/lynx.cfg
    sed -i 's/\(ENABLE_LYNXRC:.*\):OFF/\1:ON/' /etc/lynx-cur/lynx.cfg

    cp $VERBOSE -a /etc/locale.gen{,.dpkg-dist}
    sed -i 's/\(#\+\ \+\)\+\(ru_RU\|en_US\)/\2/' /etc/locale.gen
    locale-gen
    echo "LC_CTYPE=ru_RU.UTF-8" > /etc/default/locale

    cp $VERBOSE -a /etc/screenrc{,.dpkg-dist}
    sed 's/^#\(startup_message[[:blank:]]\+off\)/\1/' -i /etc/screenrc
    echo "shell -bash" >> /etc/screenrc

    cp $VERBOSE -a /etc/ssh/sshd_config{,.dpkg-dist}
    sed -e 's/.*#.*\(ListenAddress[[:blank:]]\+0\.0\.0\.0\)/\1/' \
        -e 's/^[^#]*\(ListenAddress[[:blank:]]\+::\)/#\1/' \
        -i /etc/ssh/sshd_config

    cd /etc/skel/
    cp $VERBOSE -a .lynxrc /root
    cd
    echo "MAIL=/var/mail/$HOSTNAME" >> /root/.profile
    echo "root: $HOSTNAME" >> /etc/aliases

    LINUX_VERSION=\$(
    ls -1v /boot/vmlinuz-* |
    tail -1 |
    sed 's/\/boot\/vmlinuz-//'
    )

    useradd -m -c "System Administrator" $HOSTNAME
    echo -e  "$PASSWORD\n$PASSWORD" 2>&1|
    passwd $HOSTNAME
    # passwd -l root

    fortune | mail -s "First Mail" root
    fortune | mail -s "First Mail" $HOSTNAME

    update-rc.d iptables defaults

    echo "kernel.printk = 4 4 1 7" > /etc/sysctl.d/printk.conf

    if [ -f /etc/syslog.conf ]; then
        SYSLOG_CONF=/etc/syslog.conf
    else
        SYSLOG_CONF=/etc/rsyslog.conf
    fi
    cp $VERBOSE -a \$SYSLOG_CONF{,.dpkg-dist}
    sed -i 's/\*\.\*/&;kern.!=warning/g' \$SYSLOG_CONF
    sed -i 's/kern\.\*/&;kern.!=warning/g' \$SYSLOG_CONF
    sed -i 's/\*\.=warn/&;kern.!=warning/g' \$SYSLOG_CONF
    sed -i 's/\*\.warn/&;kern.!=warning/g' \$SYSLOG_CONF
    echo 'kern.=warning  /var/log/kern.warning' >> \$SYSLOG_CONF

    cd /boot/grub
    if [ -n "$BOOT_SPLASH" ]; then
        wget -nv $VERBOSE -P /boot/grub \$(echo $BOOT_SPLASH)
        if file /boot/grub/\$(basename $BOOT_SPLASH) 2>&1| grep -qiw image;\
        then
            ln $VERBOSE -sf \$(basename $BOOT_SPLASH)  moreblue-orbit-grub.tga
        fi
    else
        ln $VERBOSE -sf /usr/share/images/grub/Lake_mapourika_NZ.tga \
            moreblue-orbit-grub.tga
        cd -
    fi

    chmod 755 /etc/grub.d/06_local_theme
    sed 's/\(GRUB_CMDLINE_LINUX_DEFAULT=\)"\(.*\)quiet\(.*\)"/\1"\2 \3"/' \
        /etc/default/grub

    chmod $VERBOSE ugo+rx /usr/lib/cgi-bin/quote
EOF
} # install_packages ()

install_boot_loader ()
{
    # We should mount boot device in chroot environment to to install boot loader
    # Without sh it stopped at this point
    chroot ${TARGET} sh <<-EOB
    echo "Installing boot loader ..."
    SLEEP=10
    CYCLE=12

    [ -n "$MDADM" ] &&
    mdadm -D $DEVICE &&
    while ! mdadm -D $DEVICE |\
        grep -q "State : clean" && [ $((CYCLE--)) -gt 0 ]; do
        sleep \$SLEEP
        if [ \$CYCLE -lt 1 ]; then
            echo "Don't wait anymore for raid sync"
            mdadm -D $DEVICE | grep "State :"
        fi
    done
    if ! $STRIPE; then
        [ -n "$MDADM" ] &&
        mdadm -D $DEVICE &&
        echo "(hd0) $DEVICE" > /boot/grub/device.map
        if $PARTITION; then
            mount $VERBOSE ${PART}2 /boot/efi
        fi
        grub-install $DEVICE
        if [ "$GRUB" = "grub-efi" ]; then
            mkdir $VERBOSE -p /boot/efi/EFI/boot
            cp $VERBOSE -a /boot/efi/EFI/{debian/grub,boot/boot}x64.efi
        fi
    else
        case $GRUB in
            grub-efi)
                mkdir $VERBOSE /boot/efi
                for MEMBER in ${ARRAY[@]}; do
                    mkfs.vfat $VERBOSE \${MEMBER}2
                    mount $VERBOSE \${MEMBER}2 /boot/efi
                    grub-install \${MEMBER}
                    mkdir $VERBOSE -p /boot/efi/EFI/boot
                    cp $VERBOSE -a /boot/efi/EFI/{debian/grub,boot/boot}x64.efi
                    umount $VERBOSE /boot/efi
                done
                ;;
            grub-pc)
                for MEMBER in ${ARRAY[@]}; do
                    grub-install \${MEMBER}
                    echo \${MEMBER}
                done
            ;;
        esac
    fi
    update-grub
EOB
} # install_boot_loader ()

save_install_list ()
{
    [ -d /etc/install-debian/install ] &&
    tar cf - $VERBOSE -C /etc/install-debian/install . |
    tar xf - -C $TARGET
} # save_install_list () 

finish_foot ()
{
    echo "
    --=== Finish $(basename "$0") at $(date), elapsed $SECONDS seconds. ===--
    "
} # finish_foot () 

save_log ()
{
    [ -f "$LOG" ] &&
    cp -a "$LOG" $TARGET/root
    umount_target
} # save_log ()

send_password ()
{
    #############################
    ## SEND LOGIN AND PASSWORD ##
    #############################

    echo "
    Host:     $ADDRESS
    User:     $HOSTNAME
    Password: $PASSWORD

    " |
    if [ -f "$LOG" ]; then
        cat - "$LOG"
    else
        cat
    fi |
    mail -s "New Debian Host" "$MAILTO"

    echo "
    System Administrator account:
        Login:     $HOSTNAME
        Password:  $PASSWORD

    sent to $MAILTO

    Root account blocked. To become root:
        sudo -u root su -

    "
} # send_password () 

init_variables
get_options "$@"
set_logging
set_raid_level
check_utils
space_cutting
check_space
start_warning
set_logging
start_head
clean_space
create_space
install_base_system
configure_system
install_packages
install_boot_loader
save_install_list
finish_foot
save_log
send_password
exit $?

cat > /dev/null <<EOT
###  BEGIN /etc/profile.d/local.sh  ###
#
PATH=/opt/bin:$PATH
alias dictl='dictl -d mueller7accent'
export EDITOR=vim
export HOSTNAME
alias ls='ls'
[ $(id -u) -gt 0 ] && umask g+w
###  END /etc/profile.d/local.sh  ###

###  BEGIN /etc/vim/vimrc.local  ###
syntax enable
set background=dark
set autoindent
set nobackup
set nowritebackup
set backupcopy=no
set termencoding=utf-8
set fileencoding=utf-8
set modeline
set sw=4
set ts=4
set expandtab
set nois
###  END /etc/vim/vimrc.local  ###

###  BEGIN /etc/Muttrc.d/local.rc  ###
ignore *
unignore From: To: Cc: Subject: Date:
auto_view text/html
bind pager $ bottom
set mbox=~/Mail/inbox
set record=~/Mail/sent
set use_from
set envelope_from
set editor="vim \'+set tw=72\'"
set pager_stop
set charset=utf-8
set allow_8bit=yes
set send_charset=utf-8
set rfc2047_parameters
set ascii_chars=yes
set meta_key=no
# vim: filetype=muttrc:
###  END /etc/Muttrc.d/local.rc  ###

###  BEGIN /etc/skel/.lynxrc  ###
accept_all_cookies=on
raw_mode=on
force_cookie_prompt=yes
force_ssl_prompt=yes
ftp_passive=on
set_cookies=on
show_color=never
user_mode=ADVANCED
verbose_images=off
make_pseudo_alts_for_inlines=off
###  END /etc/skel/.lynxrc  ###

###  BEGIN /etc/lynx-cur/local.cfg  ###
STARTFILE:/dev/null
# vim: filetype=lynx: 
###  END /etc/lynx-cur/local.cfg  ###

###  BEGIN /etc/network/iptables  ###
#
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]

-A INPUT ! -i $IFACE -m state --state NEW -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -p tcp -m tcp --dport 113 -j REJECT
#-A INPUT -j LOG --log-prefix "INPUT DROP: " 

#-A FORWARD -j LOG --log-prefix "FORWARD DROP: "
COMMIT

*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

###  END /etc/network/iptables  ###

###  BEGIN /etc/network/inactive  ###
#
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
###  END /etc/network/inactive  ###

###  BEGIN /etc/init.d/iptables  ###
#!/bin/bash
### BEGIN INIT INFO
# Provides:          iptables
# Required-Start:    mountdevsubfs
# Required-Stop:
# Default-Start:     S
# Default-Stop:
# Short-Description: Firewall
# Description:       iptables firewall
#
### END INIT INFO

RULES=/etc/network/iptables
INACTIVE=/etc/network/inactive
if ! [ -f $RULES ]; then
        echo "
        Rules file $RULES not available.
        Exiting ...
        "
        exit 1
fi
echo "Firewall $1"
case $1 in
        start)
                iptables-restore < $RULES
        ;;
        stop)
                if [ -f $INACTIVE ]; then
                        iptables-restore -c < $INACTIVE
                else
                        iptables -F
                fi
        ;;
        *)
                echo "Usage:
                $0 [start|stop]
                "
        ;;
esac
###  END /etc/init.d/iptables  ###

###  BEGIN /etc/apt/apt.conf.d/cache  ###
APT::Cache::AllVersions false;
APT::Cache-Limit 0x2000000;
###  END /etc/apt/apt.conf.d/cache  ###

###  BEGIN /etc/grub.d/06_local_theme  ###
#!/bin/bash
echo set color_normal=yellow/black
###  END /etc/grub.d/06_local_theme  ###

###  BEGIN /usr/lib/cgi-bin/quote  ###
#!/bin/bash

LC_CTYPE="ru_RU.UTF-8"
export LC_CTYPE
echo "Content-Type: text/html; charset=utf-8

<html>
<head>
    <title>
    $(fortune -sn 60 ru .)
    </title>
</head>
<body>
    <center>
    <h2><big>
    <a href="">$(fortune -sn 60 ru .)</a>
    <br>
    </big></h2>
"
fortune ru . | sed 's/$/\<br\>/'
echo "
    </center>
</body>
</html>
"
###  END /usr/lib/cgi-bin/quote  ###

###  BEGIN /var/www/index.shtml  ###
    <!--#include virtual="/cgi-bin/quote" -->
###  END /var/www/index.shtml  ###

###  BEGIN /etc/X11/Xresources/x11-local  ###
! \$Id$
URxvt.background: DarkSlateGray
URxvt.foreground: Wheat
URxvt.geometry: 100x45
! URxvt.font: 10x20
! URxvt.font: 9x15
URxvt.font: xft:Mono
URxvt.loginShell: true
URxvt.scrollBar: false
XLock.font: -sony-fixed-medium-r-*-*-24-*-*-*-*-*-*
###  END /etc/X11/Xresources/x11-local  ###

###  BEGIN /root/.muttrc  ###
set folder = /home/$HOSTNAME/Mail
set mbox=\$folder/inbox
set record=\$folder/sent
###  END /root/.muttrc  ###

###  BEGIN   ###
###  END   ###
EOT
