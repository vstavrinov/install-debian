#!/bin/bash

# Auto install Debian base system
# (C) Vladimir Stavrinov <vstavrinov@gmail.com>
# License: latest GPL at http://www.gnu.org/licenses/

#set -x -v

VERSION=2.3.8
if [ "$(id -u)" -ne 0 ]; then
    echo "
    Your should be root to run this script.
    "
    exit
fi

SELF_NAME=$(basename "$0")

unset ADDRESS || true
unset APT || true
unset APT_OPTIONS || true
unset ARCH || true
unset BOOT || true
unset DEVICE || true
unset CREATE || true
unset ARRAY || true
unset LEVEL || true
unset FS_TYPE || true
unset DOMAIN || true
unset GATEWAY || true
unset HOSTNAME
unset HOSTNAME || true
unset LOG || true
unset MIRROR || true
unset NAMESERVER || true
unset ORACLE_OWNER || true
unset PARTITION || true
unset ROOT || true
unset SUITE || true
unset TIMEZONE || true
unset TMP || true
unset USR || true
unset home || true
unset opt || true
unset srv || true
unset var || true

: "${LOG:=${SELF_NAME}.log}"

[ -r /etc/install-debian/default.conf ] && . /etc/install-debian/default.conf
[ -r /etc/install-debian/local.conf ] && . /etc/install-debian/local.conf


kernels_number=2
kernel_size=64
modules_size=384
loader_size=16
base_size=32

# Cylinder size
CS=$((512*63*255))


export DEBIAN_FRONTEND="noninteractive"
: "${APT:=apt-get}"

####################
## INIT VARIABLES ##
####################

init_variables ()
{
    [ -n "$VERBOSE" ] && echo "Init Variables start"
    CORE=/dev/md0
    RAID=/dev/md1
    GROUP=sys
    if [ -z "$DEVICE" ] && [ -z "$ARRAY" ]; then
        DEVICE=$(gawk '{
                if (SIZE < $3 &&
                    system("mdadm -D /dev/"$4" > /dev/null 2>&1")) {
                    SIZE=$3;
                    DEVICE=$4
                }
            }
            END {
                print DEVICE
            }
        ' /proc/partitions )
        SIZE=$(gawk -v DEVICE="${DEVICE//\//\\/}" '{
                    if ($4 == DEVICE) print $3
                    }' /proc/partitions)
        mapfile -t ARRAY < <(gawk -v SIZE="$SIZE" '{
                    if ($3 == SIZE) printf("%s\n", "/dev/"$4)
                    }' /proc/partitions)
        DEVICE=/dev/$DEVICE
        if [ ${#ARRAY[@]} -lt 2 ]; then
            CREATE=false
            unset ARRAY
        else
            CREATE=true
        fi
    elif [ -n "$DEVICE" ] && [ -z "${ARRAY[0]}" ]; then
        CREATE=false
    fi

    : "${PARTITION:=true}"
    : "${MIRROR:=$(awk '/^deb / {LN++; if (LN == 1) print $2}' \
        /etc/apt/sources.list)}"
    : "${ARCH:=$(dpkg --print-architecture )}"
    : "${SUITE:="stable"}"
    : "${FS_TYPE:=ext4}"
    : "${ROOT:=$base_size}"
    : "${BOOT:=$(((kernel_size*kernels_number+loader_size)*12/10))}"
    : "${TMP:=128}"
    : "${USR:=$((832+(modules_size*kernels_number)*12/10))}"
    : "${var:=$((256+modules_size))}"
    : "${home:=128}"
    : "${opt:=0}"
    : "${srv:=0}"
    LIMIT=200
    RATE=5
    BIOS=2
    EFI=32
    IFACE=$(ip route | awk '/default/ {print $NF}')
    : "${ADDRESS:=$(ip addr | awk "/inet .* $IFACE/ {print \$2}")}"
    : "${GATEWAY:=$(ip route  | awk '/^default via / {print $3}')}"
    : "${HOSTNAME:=$(hostname)}"
    : "${DOMAIN:=$(domainname -d)}"
    : "${DOMAIN:="oz"}"
    : "${NAMESERVER:=$(awk '/^[[:blank:]]*nameserver/ {print $2}' \
        /etc/resolv.conf | head -1)}"
    : "${TIMEZONE:=$([ -f /etc/timezone ] && cat /etc/timezone)}"
    SHOW=false
    DEBUG=false
    NO_WARNING=false
    LOGGING=false
    TARGET="/mnt"
    DEBOOTSTRAP="debootstrap"
    PASSWORD="debian"
    #
    if [ "$ARCH" = "i386" ]; then
        if [ "$(free -g | awk '/^Mem: / {print $2}')" -ge 3 ]; then
            KERNEL="686-bigmem"
        else
            KERNEL="686"
        fi
    else
        KERNEL="$ARCH"
    fi
    [ -n "$VERBOSE" ] && echo "Init Variables finish"
} # init_variables

##################
## HELP MESSAGE ##
##################

usage ()
{
    echo "
    Auto install Debian base system

    $SELF_NAME [-ltpvdh] [-m MIRROR] [-R ROOT] [-U USR] [-B var] [-H home]
            [-O opt] [-S srv] [-I ADDRESS] [-G GATEWAY] [ -o BSOPT ] [-r LEVEL]
            [-x SPARE] [-N HOSTNAME] [-D DOMAIN] [-E NAMESERVER] [-Z TIMEZONE]
            [-u SUITE] [-a ARCH] [-K KERNEL] [-L LOG] [DEVICE ... ]

    DEVICE
        device (or devices) to install to. If not specified, the biggest one
        will be chosen.

    -m MIRROR
        to install from [ $MIRROR ]
    -a ARCH
        Architecture [ $ARCH ]
    -t
        allow untrusted mirror
    -o BSOPT
        debootstrap extra options [ $BSOPT ]
    -r LEVEL
        raid level (see mdadm)
    -x SPARE
        number of spare (eXtra) devices
    -K KERNEL
        Define kernel package as linux-image-KERNEL [ $KERNEL ]
    -u SUITE
        Distribution (suite) [ $SUITE ]
    -R ROOT
        / (root) partition size, Mb [ $ROOT ]
    -U USR
        /usr partition size, Mb [ $USR ]
    -B var
        /var partition size, Mb [ $var ]
    -H home
        /home partition size, Mb [ $home ]
    -O opt
        /opt partition size, Mb [ $opt ]
    -S srv
        /srv partition size, Mb [ $srv ]
    -I ADDRESS
        IP Adress/mask [ $ADDRESS ]
    -G GATEWAY
        Default Gateway [ $GATEWAY ]
    -N HOSTNAME
        Host Name [ $HOSTNAME ]
    -D DOMAIN
        Domain [ $DOMAIN ]
    -E NAMESERVER
        DNS address [ $NAMESERVER ]
    -Z TIMEZONE
        Time Zone [ $TIMEZONE ]
    -L LOG
        Log file to output to [ $LOG ]
    -l
        Logging output to file [ $LOG ]
    -p
        Manual partition and mount under $TARGET before install
    -e
        Clean space and exit.
    -n
        No warning dialog. Start immediately non-interactive.
    -s
        Do nothing, but Show variables values only. Strongly recommended for
        using before doing anything else.
    -V
        Version
    -v
        Verbose
    -d
        Debug
    -h
        Help

    Files:
        /etc/$SELF_NAME/$SELF_NAME.conf
            System wide config
        /etc/$SELF_NAME/local.conf
            Local config, override system settings
        /etc/$SELF_NAME/install/
            Everything from this directory will be copied to the root of new \
            system as related path
    "
    exit
} # usage ()

get_options ()

#############################
## GET COMMAND LINE OPIONS ##
#############################

{
    [ -n "$VERBOSE" ] && echo "Get Options start"
    EXCLUSIVE=false
    OPTERR=0
    while getopts r:x:m:a:o:K:u:R:U:B:H:N:O:S:I:M:G:D:E:Z:L:Vltpensvdh \
        OPTION; do
        case $OPTION in
        r)
            LEVEL=$OPTARG
            ;;
        x)
            SPARE=$OPTARG
            ;;
        m)
            MIRROR=$OPTARG
            ;;
        a)
            ARCH=$OPTARG
            ;;
        o)
            mapfile -t -d " " BSOPT < <(echo -n "$OPTARG")
            ;;
        t)
            APT_OPTIONS="$APT_OPTIONS --allow-unauthenticated"
            BSOPT+=('--no-check-gpg' )
            ;;
        K)
            KERNEL=$OPTARG
            ;;
        u)
            SUITE=$OPTARG
            ;;
        R)
            ROOT=$OPTARG
            ;;
        U)
            USR=$OPTARG
            ;;
        B)
            var=$OPTARG
            ;;
        H)
            home=$OPTARG
            ;;
        O)
            opt=$OPTARG
            ;;
        S)
            srv=$OPTARG
            ;;
        I)
            ADDRESS=$OPTARG
            ;;
        G)
            GATEWAY=$OPTARG
            ;;
        N)
            HOSTNAME=$OPTARG
            ;;
        D)
            DOMAIN=$OPTARG
            ;;
        E)
            NAMESERVER=$OPTARG
            ;;
        Z)
            TIMEZONE=$OPTARG
            ;;
        L)
            LOG=$OPTARG
            ;;
        l)
            LOGGING=true
            ;;
        p)
            PARTITION=false
            CREATE=false
            unset ARRAY
            # Find whole disk with root partition by striping out partition number and preceding 'p'
            DEVICE=$(mount |
                gawk -v TARGET=$TARGET '{
                        if ($3 == TARGET)
                        print gensub("(([0-9])p)?[0-9]+$", "\\2", 1, $1)
                    }')
            ;;
        e)
            ACTION=clean
            ;;
        n)
            NO_WARNING=true
            ;;
        s)
            SHOW=true
            ;;
        V)
            if [ -z "$VERBOSE" ]; then
                echo "
                $SELF_NAME $VERSION
                "
            else
                echo "
                $SELF_NAME $VERSION
                Auto install Debian base system
                (C) Vladimir Stavrinov <vstavrinov@gmail.com>
                "
            fi
            exit
            ;;
        v)
            VERBOSE="-v"
            ;;
        d)
            DEBUG=true
            ;;
        h|*)
            usage
            ;;
        esac
    done
    shift  $((OPTIND - 1))
        if [ -n "$1" ]; then
            if [ -z "$2" ]; then
                DEVICE=$1
                CREATE=false
                unset ARRAY
            else
                mapfile -t -d " " ARRAY < <(echo -n "${@}")
                DEVICE=${ARRAY[0]}
                CREATE=true
            fi
        fi
    ${LOGGING} && $NO_WARNING && exec < /dev/null > "${LOG}" 2>&1
    cleanup_structures
    if $SHOW; then
        show_var
        show_cleanup
        exit
    fi
} # get_options ()

set_raid_level ()
{
    [ -n "$VERBOSE" ] && echo "Set RAID start."
    if [ -n "${ARRAY[0]}" ]; then
        : "${SPARE:=$((${#ARRAY[@]}%2))}"
        if [ -z "$LEVEL" ] && [ $((${#ARRAY[@]} - SPARE)) -eq 2 ]; then
            LEVEL=mirror
        else
            : ${LEVEL:=raid10}
        fi
    fi

    case $LEVEL in
        1|raid1)
        LEVEL=mirror
        ;;
    esac
    if [ ${#ARRAY[@]} -lt 2 ] || [ "$LEVEL" = "mirror" ]; then
        STRIPE=false
    else
        STRIPE=true
    fi
    [ -n "$VERBOSE" ] && echo "Set RAID finish."
} # set_raid_level

check_utils ()
{
    [ -n "$VERBOSE" ] && echo "Check Utils start."
    UTILS="
    mdadm
    grub-install
    tar
    gawk
    cp
    debootstrap
    fdisk
    basename
    dumpe2fs
    umount
    mount
    mkswap
    mkfs
    vgdisplay
    lvcreate
    vgcreate
    pvcreate
    parted
    yes
    partx
    sort
    dmraid
    pvremove
    pvs
    $APT
    dpkg
    free
    gawk
    pr
    xargs
    find
    chroot
    dialog
    mkdir
    vgs
    vgremove
    "

    for prog in $UTILS; do
        type "$prog" > /dev/null 2>&1 ||
        MISSING="$MISSING $prog"
    done
    if [ -n "$MISSING" ]; then
        echo "
        $MISSING not found.
        You MUST have all of these utilities installed:
        "
        echo "$UTILS"
        echo "
        Exiting ...
        "
        exit
    fi

    [ -n "$VERBOSE" ] && echo "Check Utils finish."
} # check_utils

space_cutting ()
{
    ####################################
    ## CALCULATE DISK PARTITIONS SIZE ##
    ####################################
    [ -n "$VERBOSE" ] && echo "Space Cutting start."
    if $PARTITION; then
        if ! [ -b "$DEVICE" ]; then
            echo "There are no such block device $DEVICE". Exiting ...
            exit 1
        fi

        DISK=$(awk "{
            if (\"${DEVICE#/dev/}\" == \$NF) print int(\$(NF-1)/1024)
            }" /proc/partitions)

        $STRIPE && DISK=$((DISK*(${#ARRAY[@]}/2)))

        if [ -z "$DISK" ]; then
            echo "$DEVICE: no such device. Specify other one."
            exit
        fi

        RAM=$(free -m | gawk '/^Mem:/ {print $2}')
        case 0 in
            $([ "$RAM" -gt 4096 ]; echo $?))
            SWAP=4096
            ;;

            $([ "$RAM" -lt 2048 ]; echo $?))
            SWAP=2047
            ;;

            *)
            SWAP=$RAM
            ;;
        esac
        VOLUME=$((USR +
                    TMP +
                    ROOT +
                    SWAP +
                    home +
                    opt +
                    srv +
                    var))

        if [ $DISK -lt $VOLUME ]; then
            SWAP=10
            VOLUME=$((USR +
                        TMP +
                        ROOT +
                        SWAP +
                        home +
                        opt +
                        srv +
                        var))

        fi
        if ! $STRIPE; then
            RESERVE=$((DISK*RATE/100))
            [ $RESERVE -lt $LIMIT ] && RESERVE=$LIMIT
            EXTENT=$((DISK-RESERVE))
        else
            EXTENT=$((DISK-BOOT))
            :
        fi

        var=$((VOLUME -
                USR -
                ROOT -
                TMP -
                SWAP -
                home -
                opt -
                srv))


        # Check device if it is dmaraid mdadm to install it,

        if dmraid -s "$(basename "$DEVICE")"; then
            DMRAID="dmraid"
        elif mdadm -D "$DEVICE" || [ ${#ARRAY[@]} -gt 1 ]; then
            MDADM="mdadm"
            :
        fi

    fi # if $PARTITION; then
    [ -n "$VERBOSE" ] && echo "Space Cutting finish"
} # space_cutting ()

show_var ()
{
    ######################
    ## OUTPUT VARIABLES ##
    ######################

    echo " APT=$APT
    APT_OPTIONS=$APT_OPTIONS
    VERBOSE=$VERBOSE
    MIRROR=$MIRROR
    ARCH=$ARCH
    KERNEL=$KERNEL
    SUITE=$SUITE
    DEVICE=$DEVICE
    LEVEL=$LEVEL
    SPARE=$SPARE
    CREATE=$CREATE
    PARTITION=$PARTITION
    BOOT=$BOOT
    ROOT=$ROOT
    USR=$USR
    TMP=$TMP
    SWAP=$SWAP
    var=$var
    home=$home
    opt=$opt
    srv=$srv
    DISK=$DISK
    EXTENT=$EXTENT
    VOLUME=$VOLUME
    RESERVE=$RESERVE
    ADDRESS=${ADDRESS}
    GATEWAY=${GATEWAY}
    NAMESERVER=${NAMESERVER}
    HOSTNAME=${HOSTNAME}
    DOMAIN=${DOMAIN}
    TIMEZONE=${TIMEZONE}
    LOG=$LOG " |
    pr -J -w 78 -t --columns=2 |
    gawk '{printf(" %-39s %-39s\n", $1, $2)}'
    echo " ARRAY=(${ARRAY[*]})"
} # show_var ()

chrooted_procs ()
{
    [ -n "$VERBOSE" ] && echo Remaining chrooted procs ...
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET -exec file {} + 2>/dev/null |
    grep -E "[0-9]" && [ $((--LOOP)) -gt 0 ]
}

umount_target ()
{
    [ -n "$VERBOSE" ] && echo "Umount Target start."
    LOOP=3
    [ -n "$VERBOSE" ] && echo Finding chrooted procs ...
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET -exec file {} + 2>/dev/null
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET 2>/dev/null |
    grep -Eo "[0-9]+" |
    xargs -r ps wwu
    while chrooted_procs; do
        [ -n "$VERBOSE" ] && echo Killing chrooted procs ...
        find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET 2>/dev/null |
        grep -Eo "[0-9]+" |
        if
            [ $((--LOOP)) -eq 1 ]
        then
            xargs -r kill -9
        else
            xargs -r kill
        fi
    done
    awk "/${TARGET//\//\\/}/ {print \$2}" /proc/mounts |
    sort -r |
    uniq |
    xargs -r umount $VERBOSE -l
    [ -n "$VERBOSE" ] && echo "Umount Target finish."
} # umount_target ()

check_space ()
{
    [ -n "$VERBOSE" ] && echo "Check Space start."
    if [ $VOLUME -gt $EXTENT ] && $PARTITION; then
        echo "
        Disk is too small. Disk size should be more then $((VOLUME+RESERVE))
        Mb. Can not proceed. Adjust partition's size or do partitioning manual
        and use -p option.
        "
        show_var
        echo "
        Exiting ...
        "
        exit

    fi
    [ -n "$VERBOSE" ] && echo "Check Space finish."
} # check_space ()

show_cleanup ()
{
    [ -n "$ARRAY_DEVICES" ] &&
    echo "    These arrays will be destroyed:" $ARRAY_DEVICES
    [ -n "$ARRAY_MEMBERS" ] &&
    echo "    These arrays members will be zerroed:" $ARRAY_MEMBERS
    [ -n "$VGS" ] &&
    echo "    These volume groups will be removed:" $VGS
    [ -n "$PVS" ] &&
    echo "    These physical volumes will be removed:" $PVS
} # show_cleanup ()

cleanup_structures ()
{
    [ -n "$VERBOSE" ] &&
    echo "Figure out structures that include chosen disks"
    ARRAY_DEVICES="$( mdadm -Ds |
        awk '{print $2}'|
        while read -r MD; do
            mdadm -DY $MD |
            awk -F= '/MD_DEVICE_ev_.*_DEV/ {print $2}'|
            while read -r MD_DEV; do
                for DEV in $DEVICE ${ARRAY[@]}; do
                    [ "${MD_DEV#$DEV}" != "$MD_DEV" ] &&
                    echo $MD
                done
            done
        done | sort | uniq)"
    [ -b $RAID ] && [ "${ARRAY_DEVICES/$RAID/}" == "$ARRAY_DEVICES" ] &&
    ARRAY_DEVICES="$ARRAY_DEVICES $RAID"
    [ -b $CORE ] && [ "${ARRAY_DEVICES/$CORE/}" == "$ARRAY_DEVICES" ] &&
    ARRAY_DEVICES="$ARRAY_DEVICES $CORE"

    ARRAY_MEMBERS="$( mdadm -DsY |
        awk -F= '/MD_DEVICE_ev_.*_DEV/ {print $2}'|
        while read -r MD_DEV; do
            for DEV in $DEVICE ${ARRAY[@]}; do
                [ "${MD_DEV#$DEV}" != "$MD_DEV" ] &&
                echo $MD_DEV
            done
        done | sort | uniq)"

    VGS="$(pvs --noheadings -o pv_name,vg_name |
        while read -r PV VG; do
            for DEV in $DEVICE ${ARRAY[@]} $ARRAY_DEVICES; do
                [ "${PV#$DEV}" != "$PV" ] &&
                echo $VG
            done
        done | sort | uniq)"
    vgs $GROUP 2> /dev/null && [ "${VGS/$GROUP/}" == "$VGS" ] &&
    VGS="$VGS $GROUP"
    PVS="$(pvs --noheadings -o pv_name,vg_name |
        while read -r PV VG; do
            for DEV in $DEVICE ${ARRAY[@]} $ARRAY_DEVICES; do
                [ "${PV#$DEV}" != "$PV" ] &&
                echo $PV
            done
        done | sort | uniq)"

} # cleanup_structures ()

start_warning ()
{
    if ! $NO_WARNING; then
        WIDTH=${COLUMNS:=75}
        if [ -n "$VERBOSE" ]; then
            VARS="$(show_var)"
            HEIGHT=$(($(echo "$VARS" | wc -l)+13))
        else
            VARS=""
            HEIGHT=15
        fi
        dialog --colors --no-collapse --defaultno --yesno " \Zb\Z4Install \
            Debain GNU/Linux\Zn\ZB

$VARS

    \Zb\Z1WARNING!\Zn\ZB This will destroy all data on the hard disks:

    \Zr\Zb$(if [ ${#ARRAY[@]} -gt 1 ]; then echo "${ARRAY[@]}"; else \
        echo "$DEVICE"; fi)\ZB\ZR

$(show_cleanup)

    Are Your sure to continue?  " $HEIGHT $WIDTH || exit
        ${LOGGING} && exec < /dev/null >> "${LOG}" 2>&1
    fi
} # start_warning ()

start_head ()
{
    echo "
    Starting with parameters:
    "
    show_var

    echo "
    --=== Starting $(basename "$0") at $(date), elapsed $SECONDS seconds. ===--
    "
    [ -d $TARGET ] || mkdir $VERBOSE $TARGET
} # start_head ()

clean_space ()
{
    if "$PARTITION"; then
        [ -n "$VERBOSE" ] && echo "Clean Space start"

        umount_target
        invoke-rc.d lvm2 restart
        [ -n "$VERBOSE" ] && echo "Remove volume groups and volumes"
        [ -n "$VGS" ] &&
        vgremove $VERBOSE -y -f -f $VGS
        [ -n "$VERBOSE" ] && echo "Remove physical volumes"
        [ -n "$PVS" ] &&
        pvremove $VERBOSE -y -f -f $PVS
        # stop raid
        [ -n "$ARRAY_DEVICES" ] &&
        mdadm -S $ARRAY_DEVICES
        [ -n "$VERBOSE" ] && echo "Remove raid members"
        [ -n "$ARRAY_MEMBERS" ] &&
        mdadm $VERBOSE --zero-superblock $ARRAY_MEMBERS
        [ -n "$VERBOSE" ] && echo "Remove partitions"
        for MEMBER in ${DEVICE} ${ARRAY[@]}; do
            parted -sm $MEMBER mklabel gpt
            dd if=/dev/zero of=$MEMBER count=4
        done
    fi # if $PARTITION
    [ -n "$VERBOSE" ] && echo "Clean Space finish"
    [ "$ACTION" = "clean" ] && exit
} # clean_space ()

create_space ()
{
    #######################################################
    # PREPARE TARGET TO INSTALL TO: PARTITIONING IF NEED ##
    # AND CREATING FSTAB                                 ##
    #######################################################
    if $PARTITION; then
        ###############################
        ## PARTITIONING ENITIRE DISK ##
        ###############################
        # create single mirror array
        if ! $STRIPE; then
            if $CREATE; then
                echo yes |
                mdadm $VERBOSE -C $CORE -e 0 -x $SPARE -a part \
                    -n $((${#ARRAY[@]}-SPARE))                 \
                    -l mirror "${ARRAY[@]}"
                DEVICE=$CORE
            fi
            POOL=("$DEVICE")
        else
            mapfile -t -d " " POOL < <(echo -n "${ARRAY[@]}")
        fi
        PART="${DEVICE/$PART%*[0-9_]/${DEVICE}p}"

        ###############################################
        ## CALCULATE PARTITIONS BORDERS BY CYLINDERS ##
        ###############################################

        # partitioning
        for MEMBER in ${POOL[@]}; do
            [ -n "$VERBOSE" ] && echo Start partitioning  "$MEMBER"  ...
            if ! $STRIPE; then
                extent_end=$((BIOS+EFI+EXTENT-1))
                parted "$MEMBER"                                  \
                    mklabel gpt                                   \
                    unit MiB                                      \
                    mkpart primary ext2 1 $BIOS                   \
                    set 1 bios_grub on                            \
                    mkpart primary fat32 $BIOS $((BIOS+EFI))      \
                    mkpart primary ext2 $((BIOS+EFI)) $extent_end \
                    set 2 boot on                                 \
                    quit
            else
                parted -s "$MEMBER" mklabel gpt
                boot_end=$((BIOS+EFI+BOOT))
                extent_end=$(parted -sm $DEVICE unit MiB print |
                    awk -F: -v NODE=$DEVICE '{
                        if ($1 == NODE) print gensub("MiB", "", 1, $2)-1
                        }')
                parted "$MEMBER"                                \
                    unit MiB                                    \
                    mkpart primary ext2 1 $BIOS                 \
                    set 1 bios_grub on                          \
                    mkpart primary fat32 $BIOS $((BIOS+EFI))    \
                    mkpart primary ext2 $((BIOS+EFI)) $boot_end \
                    set 2 boot on                               \
                    mkpart primary ext2 $boot_end $extent_end   \
                    quit
            fi
            [ -n "$VERBOSE" ] && echo Finish partitioning  "$MEMBER"  ...
        done # for MEMBER in ${POOL[@]}; do

        # create double raid arrays
        if $STRIPE && $CREATE; then
            echo yes |
            mdadm -C $CORE -x $SPARE -a md \
                -n $((${#ARRAY[@]}-SPARE)) \
                -l mirror \
                $(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\13/g')
            DEVICE=$CORE
            mdadm -C $RAID -x $SPARE -a md \
                -n $((${#ARRAY[@]}-SPARE)) \
                -l $LEVEL \
                $(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\14/g')
        fi

        ############################
        ## CREATE LOGICAL VOLUMES ##
        ############################

        # If disk device name end with number (mdadm is case), then append 'p'
        # to further use it in partition device name.

        if ! $STRIPE; then
            sleep 2
            pvcreate -f -f -y $VERBOSE ${PART}3 || exit
            vgcreate $VERBOSE $GROUP ${PART}3
            lvcreate $VERBOSE -y -L ${BOOT} -n boot $GROUP
        else
            pvcreate -f -f -y $VERBOSE $RAID || exit
            vgcreate $VERBOSE $GROUP $RAID
        fi
        lvcreate $VERBOSE -y -L "${ROOT}" -n apex $GROUP
        lvcreate $VERBOSE -y -L "${USR}" -n usr $GROUP
        lvcreate $VERBOSE -y -L ${SWAP} -n swp $GROUP
        lvcreate $VERBOSE -y -L ${TMP} -n tmp $GROUP

        for VOL in var home opt srv; do
            EXTENT=$(vgdisplay -c $GROUP | gawk -F: '{print $13*$16}')
            eval SIZE=\$${VOL}
            [ $((SIZE*1024)) -gt "$EXTENT" ] && SIZE=$((EXTENT/1024))
            [ $SIZE -gt 0 ] && lvcreate $VERBOSE -y -L ${SIZE} -n $VOL $GROUP
        done
        if ! $STRIPE; then
            mkfs.vfat $VERBOSE ${PART}2
        else
            mkfs $VERBOSE -L boot -t $FS_TYPE $CORE
        fi
        for POINT in /dev/"$GROUP"/*; do
            mkfs $VERBOSE -L "$(basename "$POINT")" -t $FS_TYPE "$POINT"
        done

        ######################################
        ## MOUNT ALL PARTITIONS AND VOLUMES ##
        ######################################

        mkswap /dev/$GROUP/swp
        ROOT_DEVICE=/dev/$GROUP/apex
        mount $VERBOSE $ROOT_DEVICE "${TARGET}"
        for POINT in boot usr tmp var home opt srv; do
            [ -d "${TARGET}/${POINT}" ] ||
            mkdir $VERBOSE "${TARGET}/${POINT}"
        done
        if ! $STRIPE; then
            mount $VERBOSE /dev/$GROUP/boot "${TARGET}/boot"
            mkdir "${TARGET}/boot/efi"
            mount $VERBOSE ${PART}2 "${TARGET}/boot/efi"
        else
            mount $VERBOSE $CORE "${TARGET}/boot"
        fi
        ###################
        ## PREPARE FSTAB ##
        ###################

        FSTAB="proc /proc  proc defaults 0 0
        /dev/$GROUP/apex / $FS_TYPE defaults 0 1"
        # Add root (/) & boot records depends on raid level to fstab
        if $STRIPE; then
            FSTAB="${FSTAB}
            $CORE /boot $FS_TYPE defaults 0 2"
        fi
        for POINT in /dev/"$GROUP"/*; do
            if [ -d "${TARGET}/$(basename "${POINT}")" ]; then
                mount $VERBOSE "$POINT" ${TARGET}/"$(basename "${POINT}")"
                FSTAB="${FSTAB}
        $POINT /$(basename "${POINT}" ) $FS_TYPE defaults 0 2"
            fi
        done
        FSTAB="${FSTAB}
        /dev/$GROUP/swp none swap sw 0 0"
    else # if $PARTITION
        PART="${DEVICE/$PART%*[0-9_]/${DEVICE}p}"
        FSTAB="proc /proc  proc defaults 0 0 $(echo
        mount |
        gawk -v TARGET=$TARGET '{
            if ($3 ~ TARGET) {
                gsub(TARGET,"", $3)
                "blkid -s UUID -o value "$1"" | getline UUID
                if ($3 == "") {
                    gsub("","/",$3)
                    print "UUID="UUID, $3, $5, "defaults,errors=remount-ro 0 1"
                } else {
                    print "UUID="UUID, $3, $5, "defaults 0 2"
                }
            }
        }'
        # gawk '/partition/ {print $1, "none swap sw 0 0"}' /proc/swaps
        parted -sm $DEVICE print |
        awk -F: -v PART=$PART '/swap/ {print PART$1, "none swap sw 0 0"}'
        )"
        ROOT_DEVICE=$(
            awk -v TARGET=$TARGET '{if ($2 == TARGET) print $1}' /proc/mounts)
    fi # if $PARTITION
} # create_space ()

install_base_system ()
{
    FSTAB="${FSTAB}
    sysfs  /sys     sysfs    defaults                         0 0
    udev   /dev     devtmpfs defaults                         0 0
    devpts /dev/pts devpts   \
        rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0"

    #########################
    ## INSTALL BASE SYSTEM ##
    #########################

    [ -n "$VERBOSE" ] && echo "Installing Base System ..."
    if ! $DEBOOTSTRAP ${VERBOSE:+--verbose} "${BSOPT[@]}" --arch="$ARCH" "$SUITE" $TARGET "$MIRROR"; then
        echo "Base System installation failed. Exiting ..."
        exit 1
    fi
    echo 'blacklist floppy' > $TARGET/etc/modprobe.d/blacklist-floppy.conf
} # install_base_system ()

configure_system ()
{
    ########################
    ## MAIN CONFIGURATION ##
    ########################

    echo "$FSTAB" |
    column -t > ${TARGET}/etc/fstab

    echo "
    auto lo $IFACE

    iface lo inet loopback

    iface $IFACE inet static
        address $ADDRESS
        gateway $GATEWAY

    " > ${TARGET}/etc/network/interfaces

    echo "$HOSTNAME
    " > ${TARGET}/etc/hostname

    echo "
    127.0.0.1 localhost
    ${ADDRESS%/*} ${HOSTNAME}.${DOMAIN} ${HOSTNAME}
    " > ${TARGET}/etc/hosts

    echo "
    nameserver $NAMESERVER
    search $DOMAIN
    " |
    column -t > ${TARGET}/etc/resolv.conf

    echo "
    deb $MIRROR $SUITE main contrib non-free
    #deb $MIRROR unstable main contrib non-free
    #deb $MIRROR testing main contrib non-free
    #deb $MIRROR stable main contrib non-free
    " |
    column -t > ${TARGET}/etc/apt/sources.list

    cp $VERBOSE -a ${TARGET}/etc/profile{,.dpkg-dist}

    echo "
    do_symlinks = No
    do_initrd = Yes
    do_bootloader = no
    postinst_hook = update-grub
    postrm_hook   = update-grub
    " |
    column -t > ${TARGET}/etc/kernel-img.conf

    echo "$TIMEZONE" > ${TARGET}/etc/timezone
    ln -sf $VERBOSE /usr/share/zoneinfo/"$TIMEZONE" ${TARGET}/etc/localtime

} # configure_system ()

install_packages ()
{
    #########################################
    ## INSTALL AND CONFIGURE MAIN PACKAGES ##
    #########################################

    ATTACHMENTS="
    /etc/Muttrc.d/local.rc 644
    /etc/X11/Xresources/x11-local 644
    /etc/apt/apt.conf.d/cache 644
    /etc/grub.d/06_local_theme 755
    /etc/init.d/iptables 755
    /etc/lynx/local.cfg 644
    /etc/network/inactive 600
    /etc/network/iptables 600
    /etc/profile.d/local.sh 644
    /etc/skel/.lynxrc 644
    /etc/vim/vimrc.local 644
    /root/.muttrc 644
    /usr/lib/cgi-bin/quote 755
    /var/www/index.shtml 644"
    [ -n "$VERBOSE" ] && echo "
        Extracting attached files ...
    "
    echo "$ATTACHMENTS" | grep -v '^$' |
    while read -r FILE MODE; do
        [ -d "$(dirname ${TARGET}"$FILE")" ] ||
        mkdir $VERBOSE -p "$(dirname ${TARGET}"$FILE")"
        sed -e "
            1,\%^###  BEGIN $FILE  ###$%d
            \%^###  END $FILE  ###$%,\$d
        " "$0" >> ${TARGET}"$FILE"
        chmod $VERBOSE "$MODE" ${TARGET}"$FILE"
        ls -ld ${TARGET}"$FILE"
    done

    if [ -e /sys/firmware/efi ]; then
        GRUB=grub-efi
    else
        GRUB=grub-pc
    fi

    # make udev db available in chroot for lvm used by grub
    mkdir $VERBOSE ${TARGET}/run/udev
    mount $VERBOSE --bind /run/udev ${TARGET}/run/udev

    chroot ${TARGET} su - <<-EOF
    eval  $DEBUG && set -x -v
    if ! [ -d /run/lock ]; then
        mkdir $VERBOSE -p /run/lock
        chmod $VERBOSE ugo+wt /run/lock
    fi

    mount $VERBOSE /proc
    mount $VERBOSE /sys
    mount $VERBOSE /dev
    mount $VERBOSE /dev/pts

    MAIN_LIST="
    grub-pc-bin
    $GRUB
    lvm2
    gawk
    parted
    dosfstools
    $DMRAID
    $MDADM
    sudo
    vim
    less
    mutt
    lynx
    ftp
    file
    lsof
    ssh
    screen
    exim4
    mailutils
    fortunes
    fortunes-ru
    grub-splashimages
    grub2-splashimages
    host
    procinfo
    pciutils
    usbutils
    lsscsi
    scsitools
    ntp
    lsof
    ethtool
    mtr
    nmap
    lsb-release
    \$(apt-cache search ^firmware- | awk  '{print \$1}')
    bc
    man-db
    bash-completion
    "

    # Set non-interactive mode
    export DEBIAN_FRONTEND="noninteractive"
    #export DEBIAN_NOWARNINGS="yes"
    #export DEBCONF_PRIORITY="critical"

    #echo -e \\\\t |
    $APT $APT_OPTIONS -y update
    $APT $APT_OPTIONS -y install \$MAIN_LIST
    $APT clean
    $APT $APT_OPTIONS -y install linux-image-$KERNEL

    cd /bin
    ln $VERBOSE -sf bash sh
    cd -

    /etc/init.d/exim4 stop
    /etc/init.d/ssh stop

    echo "$HOSTNAME ALL=(ALL)NOPASSWD: ALL" >> /etc/sudoers

    ln $VERBOSE -s /usr/games/fortune /usr/bin

    update-alternatives --set editor /usr/bin/vim.basic

    cp  $VERBOSE -a /etc/Muttrc.d/colors.rc{,.dpkg-dist}
    sed -e 's/^\([^#]\+\)/#\1/' \
        -e 's/#.*\<color\>.*\<normal\>.*/color normal default default/' \
        -i /etc/Muttrc.d/colors.rc

    echo "# vim: filetype=muttrc:" >> /etc/Muttrc.d/colors.rc

    cp $VERBOSE -a  /etc/lynx/lynx.lss{,.dpkg-dist}
    sed -i 's/\\(^normal:\|^default:\\)/#\\1/' /etc/lynx/lynx.lss
    cp $VERBOSE -a /etc/lynx/lynx.cfg{,.dpkg-dist}
    sed -i 's/^#\\(ENABLE_LYNXRC:\\)/\\1/' /etc/lynx/lynx.cfg
    sed -i 's/\(ENABLE_LYNXRC:.*\):OFF/\1:ON/' /etc/lynx/lynx.cfg

    cp $VERBOSE -a /etc/locale.gen{,.dpkg-dist}
    sed -i 's/\(#\+\ \+\)\+\(ru_RU\|en_US\)/\2/' /etc/locale.gen
    locale-gen
    echo "LC_CTYPE=ru_RU.UTF-8" > /etc/default/locale

    cp $VERBOSE -a /etc/screenrc{,.dpkg-dist}
    sed 's/^#\(startup_message[[:blank:]]\+off\)/\1/' -i /etc/screenrc
    echo "shell -bash" >> /etc/screenrc

    cp $VERBOSE -a /etc/ssh/sshd_config{,.dpkg-dist}
    sed -e 's/.*#.*\(ListenAddress[[:blank:]]\+0\.0\.0\.0\)/\1/' \
        -e 's/^[^#]*\(ListenAddress[[:blank:]]\+::\)/#\1/' \
        -i /etc/ssh/sshd_config

    cd /etc/skel/
    cp $VERBOSE -a .lynxrc /root
    cd
    echo "MAIL=/var/mail/$HOSTNAME" >> /root/.profile
    echo "root: $HOSTNAME" >> /etc/aliases

    LINUX_VERSION=\$(
    ls -1v /boot/vmlinuz-* |
    tail -1 |
    sed 's/\/boot\/vmlinuz-//'
    )

    useradd -m -c "System Administrator" $HOSTNAME
    echo -e  "$PASSWORD\n$PASSWORD" 2>&1|
    passwd $HOSTNAME
    passwd -l root

    fortune | mail -s "First Mail" root
    fortune | mail -s "First Mail" $HOSTNAME

    update-rc.d iptables defaults

    echo "kernel.printk = 4 4 1 7" > /etc/sysctl.d/printk.conf

    if [ -f /etc/syslog.conf ]; then
        SYSLOG_CONF=/etc/syslog.conf
    else
        SYSLOG_CONF=/etc/rsyslog.conf
    fi
    cp $VERBOSE -a \$SYSLOG_CONF{,.dpkg-dist}
    sed -i 's/\*\.\*/&;kern.!=warning/g' \$SYSLOG_CONF
    sed -i 's/kern\.\*/&;kern.!=warning/g' \$SYSLOG_CONF
    sed -i 's/\*\.=warn/&;kern.!=warning/g' \$SYSLOG_CONF
    sed -i 's/\*\.warn/&;kern.!=warning/g' \$SYSLOG_CONF
    echo 'kern.=warning  /var/log/kern.warning' >> \$SYSLOG_CONF

    cd /boot/grub
    if [ -n "$BOOT_SPLASH" ]; then
        wget -nv $VERBOSE -P /boot/grub \$(echo $BOOT_SPLASH)
        if file /boot/grub/\$(basename $BOOT_SPLASH) 2>&1| grep -qiw image;\
        then
            ln $VERBOSE -sf \$(basename $BOOT_SPLASH)  moreblue-orbit-grub.tga
        fi
    else
        ln $VERBOSE -sf /usr/share/images/grub/Lake_mapourika_NZ.tga \
            moreblue-orbit-grub.tga
        cd -
    fi

    chmod 755 /etc/grub.d/06_local_theme
    sed 's/\(GRUB_CMDLINE_LINUX_DEFAULT=\)"\(.*\)quiet\(.*\)"/\1"\2 \3"/' \
        /etc/default/grub

    chmod $VERBOSE ugo+rx /usr/lib/cgi-bin/quote
EOF
} # install_packages ()

install_boot_loader ()
{
    # We should mount boot device in chroot environment to to install boot loader
    # Without sh it stopped at this point
    chroot ${TARGET} sh <<-EOB
    [ -n "$VERBOSE" ] && echo "Installing boot loader ..."
    SLEEP=10
    CYCLE=12

    [ -n "$MDADM" ] &&
    mdadm -D $DEVICE &&
    while ! mdadm -D $DEVICE |\
        grep -q "State : clean" && [ $((CYCLE--)) -gt 0 ]; do
        sleep \$SLEEP
        if [ \$CYCLE -lt 1 ]; then
            [ -n "$VERBOSE" ] && echo "Don't wait anymore for raid sync"
            mdadm -D $DEVICE | grep "State :"
        fi
    done
    if ! $STRIPE; then
        [ -n "$MDADM" ] &&
        mdadm -D $DEVICE &&
        echo "(hd0) $DEVICE" > /boot/grub/device.map
        if $PARTITION; then
            mount $VERBOSE ${PART}2 /boot/efi
        fi
        grub-install $DEVICE
        if [ "$GRUB" = "grub-efi" ]; then
            mkdir $VERBOSE -p /boot/efi/EFI/boot
            cp $VERBOSE -a /boot/efi/EFI/{debian/grub,boot/boot}x64.efi
        fi
    else
        case $GRUB in
            grub-efi)
                mkdir $VERBOSE /boot/efi
                for MEMBER in ${ARRAY[@]}; do
                    mkfs.vfat $VERBOSE \${MEMBER}2
                    mount $VERBOSE \${MEMBER}2 /boot/efi
                    grub-install \${MEMBER}
                    mkdir $VERBOSE -p /boot/efi/EFI/boot
                    cp $VERBOSE -a /boot/efi/EFI/{debian/grub,boot/boot}x64.efi
                    umount $VERBOSE /boot/efi
                done
                ;;
            grub-pc)
                for MEMBER in ${ARRAY[@]}; do
                    grub-install \${MEMBER}
                    echo \${MEMBER}
                done
            ;;
        esac
    fi
    update-grub
EOB
} # install_boot_loader ()

save_install_list ()
{
    [ -d /etc/install-debian/install ] &&
    tar cf - $VERBOSE -C /etc/install-debian/install . |
    tar xf - -C $TARGET
} # save_install_list ()

finish_foot ()
{
    echo "
    --=== Finish $(basename "$0") at $(date), elapsed $SECONDS seconds. ===--
    "
} # finish_foot ()

save_log ()
{
    [ -f "$LOG" ] &&
    cp -a "$LOG" $TARGET/root
    umount_target
} # save_log ()

send_password ()
{
    #############################
    ## SEND LOGIN AND PASSWORD ##
    #############################

    echo "
    System Administrator account:
        Login:     $HOSTNAME
        Password:  $PASSWORD

    Change password just after login!

    Root account blocked. Type to become root:
        sudo su -

    "
} # send_password ()

init_variables
get_options "$@"
$DEBUG && set -x -v
set_raid_level
check_utils
space_cutting
check_space
start_warning
clean_space
start_head
create_space
install_base_system
configure_system
install_packages
install_boot_loader
save_install_list
finish_foot
save_log
send_password
exit $?

cat > /dev/null <<EOT
###  BEGIN /etc/profile.d/local.sh  ###
#
PATH=/opt/bin:$PATH
alias dictl='dictl -d mueller7accent'
export EDITOR=vim
export HOSTNAME
alias ls='ls'
[ $(id -u) -gt 0 ] && umask g+w
###  END /etc/profile.d/local.sh  ###

###  BEGIN /etc/vim/vimrc.local  ###
syntax enable
set background=dark
set autoindent
set nobackup
set nowritebackup
set backupcopy=no
set termencoding=utf-8
set fileencoding=utf-8
set modeline
set sw=4
set ts=4
set expandtab
set nois
###  END /etc/vim/vimrc.local  ###

###  BEGIN /etc/Muttrc.d/local.rc  ###
ignore *
unignore From: To: Cc: Subject: Date:
auto_view text/html
bind pager $ bottom
set mbox=~/Mail/inbox
set record=~/Mail/sent
set use_from
set envelope_from
set editor="vim \'+set tw=72\'"
set pager_stop
set charset=utf-8
set allow_8bit=yes
set send_charset=utf-8
set rfc2047_parameters
set ascii_chars=yes
set meta_key=no
# vim: filetype=muttrc:
###  END /etc/Muttrc.d/local.rc  ###

###  BEGIN /etc/skel/.lynxrc  ###
accept_all_cookies=on
raw_mode=on
force_cookie_prompt=yes
force_ssl_prompt=yes
ftp_passive=on
set_cookies=on
show_color=never
user_mode=ADVANCED
verbose_images=off
make_pseudo_alts_for_inlines=off
###  END /etc/skel/.lynxrc  ###

###  BEGIN /etc/lynx/local.cfg  ###
STARTFILE:/dev/null
# vim: filetype=lynx:
###  END /etc/lynx/local.cfg  ###

###  BEGIN /etc/network/iptables  ###
#
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]

-A INPUT ! -i $IFACE -m state --state NEW -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -p tcp -m tcp --dport 113 -j REJECT
#-A INPUT -j LOG --log-prefix "INPUT DROP: "

#-A FORWARD -j LOG --log-prefix "FORWARD DROP: "
COMMIT

*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

###  END /etc/network/iptables  ###

###  BEGIN /etc/network/inactive  ###
#
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
###  END /etc/network/inactive  ###

###  BEGIN /etc/init.d/iptables  ###
#!/bin/bash
### BEGIN INIT INFO
# Provides:          iptables
# Required-Start:    mountdevsubfs
# Required-Stop:
# Default-Start:     S
# Default-Stop:
# Short-Description: Firewall
# Description:       iptables firewall
#
### END INIT INFO

RULES=/etc/network/iptables
INACTIVE=/etc/network/inactive
if ! [ -f $RULES ]; then
        echo "
        Rules file $RULES not available.
        Exiting ...
        "
        exit 1
fi
echo "Firewall $1"
case $1 in
        start)
                iptables-restore < $RULES
        ;;
        stop)
                if [ -f $INACTIVE ]; then
                        iptables-restore -c < $INACTIVE
                else
                        iptables -F
                fi
        ;;
        *)
                echo "Usage:
                $0 [start|stop]
                "
        ;;
esac
###  END /etc/init.d/iptables  ###

###  BEGIN /etc/apt/apt.conf.d/cache  ###
APT::Cache::AllVersions false;
APT::Cache-Limit 0x3000000;
###  END /etc/apt/apt.conf.d/cache  ###

###  BEGIN /etc/grub.d/06_local_theme  ###
#!/bin/bash
echo set color_normal=yellow/black
###  END /etc/grub.d/06_local_theme  ###

###  BEGIN /usr/lib/cgi-bin/quote  ###
#!/bin/bash

LC_CTYPE="ru_RU.UTF-8"
export LC_CTYPE
echo "Content-Type: text/html; charset=utf-8

<html>
<head>
    <title>
    $(fortune -sn 60 ru .)
    </title>
</head>
<body>
    <center>
    <h2><big>
    <a href="">$(fortune -sn 60 ru .)</a>
    <br>
    </big></h2>
"
fortune ru . | sed 's/$/\<br\>/'
echo "
    </center>
</body>
</html>
"
###  END /usr/lib/cgi-bin/quote  ###

###  BEGIN /var/www/index.shtml  ###
    <!--#include virtual="/cgi-bin/quote" -->
###  END /var/www/index.shtml  ###

###  BEGIN /etc/X11/Xresources/x11-local  ###
! \$Id$
URxvt.background: DarkSlateGray
URxvt.foreground: Wheat
URxvt.geometry: 100x45
! URxvt.font: 10x20
! URxvt.font: 9x15
URxvt.font: xft:Mono
URxvt.loginShell: true
URxvt.scrollBar: false
XLock.font: -sony-fixed-medium-r-*-*-24-*-*-*-*-*-*
###  END /etc/X11/Xresources/x11-local  ###

###  BEGIN /root/.muttrc  ###
set folder = /home/$HOSTNAME/Mail
set mbox=\$folder/inbox
set record=\$folder/sent
###  END /root/.muttrc  ###

###  BEGIN   ###
###  END   ###
EOT
