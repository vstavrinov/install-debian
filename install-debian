#!/bin/bash

# Auto install Debian base system
# (C) Vladimir Stavrinov <vstavrinov@gmail.com>
# License: latest GPL at http://www.gnu.org/licenses/

#set -x -v

VERSION=2.4.6
if [ "$(id --user)" -ne 0 ]; then
    echo "
    Your should be root to run this script.
    "
    exit
fi

SELF_NAME=$(basename "$0")

unset ADDRESS || true
unset METHOD || true
unset APT || true
unset APT_OPTIONS || true
unset ARCH || true
unset BOOT || true
unset BOOT_SPLASH || true
unset DEVICE || true
unset CREATE || true
unset ARRAY || true
unset LEVEL || true
unset FS_TYPE || true
unset DOMAIN || true
unset GATEWAY || true
unset HOSTNAME
unset HOSTNAME || true
unset LOG || true
unset MIRROR || true
unset NAMESERVER || true
unset ORACLE_OWNER || true
unset PARTITION || true
unset ROOT || true
unset SUITE || true
unset TIMEZONE || true
unset TMP || true
unset USR || true
unset APEX || true
unset home || true
unset opt || true
unset srv || true
unset var || true

: "${LOG:=${SELF_NAME}.log}"

[ -r /etc/install-debian/default.conf ] && . /etc/install-debian/default.conf
[ -r /etc/install-debian/local.conf ] && . /etc/install-debian/local.conf


: ${BOOT_SPLASH:="ftp://ftp.ru.debian.org/debian"}
kernels_number=2
kernel_size=64
modules_size=384
loader_size=16
base_size=32

# Cylinder size
CS=$((512*63*255))


export DEBIAN_FRONTEND="noninteractive"
: "${APT:=apt-get}"

####################
## INIT VARIABLES ##
####################

init_variables ()
{
    [ -n "$VERBOSE" ] && echo "Init Variables start"
    CORE=/dev/md0
    RAID=/dev/md1
    GROUP=sys
    APEX=apex
    if [ -z "$DEVICE" ] && [ -z "$ARRAY" ]; then
        DEVICE=$(gawk '{
                if (SIZE < $3 &&
                    system("mdadm --detail /dev/"$4" > /dev/null 2>&1")) {
                    SIZE=$3;
                    DEVICE=$4
                }
            }
            END {
                print DEVICE
            }
        ' /proc/partitions )
        SIZE=$(gawk --assign DEVICE="${DEVICE//\//\\/}" '{
                    if ($4 == DEVICE) print $3
                    }' /proc/partitions)
        mapfile -t ARRAY < <(gawk --assign SIZE="$SIZE" '{
                    if ($3 == SIZE) printf("%s\n", "/dev/"$4)
                    }' /proc/partitions)
        DEVICE=/dev/$DEVICE
        if [ ${#ARRAY[@]} -lt 2 ]; then
            CREATE=false
            unset ARRAY
        else
            CREATE=true
        fi
    elif [ -n "$DEVICE" ] && [ -z "${ARRAY[0]}" ]; then
        CREATE=false
    fi

    : "${PARTITION:=true}"
    : "${MIRROR:=$(awk '/^deb / {LN++; if (LN == 1) print $2}' \
        /etc/apt/sources.list)}"
    : "${ARCH:=$(dpkg --print-architecture )}"
    : "${SUITE:="stable"}"
    : "${FS_TYPE:=ext4}"
    : "${ROOT:=$base_size}"
    : "${BOOT:=$(((kernel_size*kernels_number+loader_size)*12/10))}"
    : "${TMP:=128}"
    : "${USR:=$((832+(modules_size*kernels_number)*12/10))}"
    : "${var:=$((512+modules_size))}"
    : "${home:=128}"
    : "${opt:=0}"
    : "${srv:=0}"
    LIMIT=200
    RATE=50
    BIOS=2
    EFI=32
    IFACE=$(ip route | awk '/default/ {print $(NF)}')
    : "${GATEWAY:=$(ip route  | awk '/^default via / {print $3}')}"
    : "${ADDRESS:=$(ip route | awk '!/^default / {print $1, $NF}' |
                    while read NETWORK ADDRESS; do
                        if [ "$(sipcalc $GATEWAY/${NETWORK#*/} |\
                        awk '/^Network address/ {print $NF}'    \
                        )" = "${NETWORK%/*}" ]; then
                            echo $ADDRESS;
                            break
                        fi;
                    done)}"
    if [ -f /var/lib/dhcp/*.leases ] &&             \
        grep --quiet "fixed-address ${ADDRESS%%/*}" \
            /var/lib/dhcp/*.leases; then
        : ${METHOD:=dhcp}
    else
        METHOD=static
    fi
    : "${HOSTNAME:=$(hostname)}"
    : "${DOMAIN:=$(domainname --domain)}"
    : "${DOMAIN:="oz"}"
    : "${NAMESERVER:=$(awk '/^[[:blank:]]*nameserver/ {print $2}' \
        /etc/resolv.conf | head -1)}"
    : "${TIMEZONE:=$([ -f /etc/timezone ] && cat /etc/timezone)}"
    SHOW=false
    DEBUG=false
    NO_WARNING=false
    LOGGING=false
    TARGET="/mnt"
    DEBOOTSTRAP="debootstrap"
    PASSWORD="debian"
    #
    if [ "$ARCH" = "i386" ]; then
        if [ "$(free --gibi | awk '/^Mem: / {print $2}')" -ge 3 ]; then
            KERNEL="686-bigmem"
        else
            KERNEL="686"
        fi
    else
        KERNEL="$ARCH"
    fi
    [ -n "$VERBOSE" ] && echo "Init Variables finish"
} # init_variables

##################
## HELP MESSAGE ##
##################

usage ()
{
    echo "
    Auto install Debian base system

    $SELF_NAME [-ltpvdh] [-m MIRROR] [-R ROOT] [-U USR] [-B var] [-H home]
            [-O opt] [-S srv] [-I ADDRESS] [-G GATEWAY] [ -o BSOPT ] [-r LEVEL]
            [-x SPARE] [-N HOSTNAME] [-D DOMAIN] [-E NAMESERVER] [-Z TIMEZONE]
            [-u SUITE] [-a ARCH] [-K KERNEL] [-L LOG] [DEVICE ... ]

    DEVICE
        device (or devices) to install to. If not specified, the biggest one
        will be chosen.

    -m MIRROR
        to install from [ $MIRROR ]
    -a ARCH
        Architecture [ $ARCH ]
    -t
        allow untrusted mirror
    -o BSOPT
        debootstrap extra options [ $BSOPT ]
    -r LEVEL
        raid level (see mdadm)
    -x SPARE
        number of spare (eXtra) devices
    -K KERNEL
        Define kernel package as linux-image-KERNEL [ $KERNEL ]
    -u SUITE
        Distribution (suite) [ $SUITE ]
    -R ROOT
        / (root) partition size, Mb [ $ROOT ]
    -U USR
        /usr partition size, Mb [ $USR ]
    -B var
        /var partition size, Mb [ $var ]
    -H home
        /home partition size, Mb [ $home ]
    -O opt
        /opt partition size, Mb [ $opt ]
    -S srv
        /srv partition size, Mb [ $srv ]
    -I ADDRESS
        IP Adress/mask, require GATEWAY [ $ADDRESS ]
    -G GATEWAY
        Default Gateway, require ADDRESS [ $GATEWAY ]
    -N HOSTNAME
        Host Name [ $HOSTNAME ]
    -D DOMAIN
        Domain [ $DOMAIN ]
    -E NAMESERVER
        DNS address [ $NAMESERVER ]
    -Z TIMEZONE
        Time Zone [ $TIMEZONE ]
    -L LOG
        Log file to output to [ $LOG ]
    -l
        Logging output to file [ $LOG ]
    -p
        Manual partition and mount under $TARGET before install
    -e
        Clean space and exit.
    -n
        No warning dialog. Start immediately non-interactive.
    -s
        Do nothing, but Show variables values only. Strongly recommended for
        using before doing anything else.
    -V
        Version
    -v
        Verbose
    -d
        Debug
    -h
        Help

    Files:
        /etc/$SELF_NAME/$SELF_NAME.conf
            System wide config
        /etc/$SELF_NAME/local.conf
            Local config, override system settings
        /etc/$SELF_NAME/install/
            Everything from this directory will be copied to the root of new \
            system as related path
    "
    exit
} # usage ()

get_options ()

#############################
## GET COMMAND LINE OPIONS ##
#############################

{
    [ -n "$VERBOSE" ] && echo "Get Options start"
    EXCLUSIVE=false
    OPTERR=0
    while getopts r:x:m:a:o:K:u:R:U:B:H:N:O:S:I:M:G:D:E:Z:L:Vltpensvdh \
        OPTION; do
        case $OPTION in
        r)
            LEVEL=$OPTARG
            ;;
        x)
            SPARE=$OPTARG
            ;;
        m)
            MIRROR=$OPTARG
            ;;
        a)
            ARCH=$OPTARG
            ;;
        o)
            mapfile -t -d " " BSOPT < <(echo -n "$OPTARG")
            ;;
        t)
            APT_OPTIONS="$APT_OPTIONS --allow-unauthenticated"
            BSOPT+=('--no-check-gpg' )
            ;;
        K)
            KERNEL=$OPTARG
            ;;
        u)
            SUITE=$OPTARG
            ;;
        R)
            ROOT=$OPTARG
            ;;
        U)
            USR=$OPTARG
            ;;
        B)
            var=$OPTARG
            ;;
        H)
            home=$OPTARG
            ;;
        O)
            opt=$OPTARG
            ;;
        S)
            srv=$OPTARG
            ;;
        I)
            ADDRESS=$OPTARG
            METHOD=static
            IP=manual
            ;;
        G)
            GATEWAY=$OPTARG
            GW=manual
            ;;
        E)
            NAMESERVER=$OPTARG
            ;;
        N)
            HOSTNAME=$OPTARG
            ;;
        D)
            DOMAIN=$OPTARG
            ;;
        Z)
            TIMEZONE=$OPTARG
            ;;
        L)
            LOG=$OPTARG
            ;;
        l)
            LOGGING=true
            ;;
        p)
            PARTITION=false
            CREATE=false
            unset ARRAY
            # Find whole disk with root partition by striping out partition number and preceding 'p'
            DEVICE=$(mount |
                gawk --assign TARGET=$TARGET '{
                        if ($3 == TARGET)
                        print gensub("(([0-9])p)?[0-9]+$", "\\2", 1, $1)
                    }')
            ;;
        e)
            ACTION=clean
            ;;
        n)
            NO_WARNING=true
            ;;
        s)
            SHOW=true
            ;;
        V)
            if [ -z "$VERBOSE" ]; then
                echo "
                $SELF_NAME $VERSION
                "
            else
                echo "
                $SELF_NAME $VERSION
                Auto install Debian base system
                (C) Vladimir Stavrinov <vstavrinov@gmail.com>
                "
            fi
            exit
            ;;
        v)
            VERBOSE="-v"
            ;;
        d)
            DEBUG=true
            ;;
        h|*)
            usage
            ;;
        esac
    done
    if ([ -n "$IP" ] && [ -z "$GW" ]) ||
        ([ -z "$IP" ] && [ -n "$GW" ]); then
        echo "
        You must not set ADDRESS or GATEWAY alone.
        Use both -I and -G options or none of them.
        "
        exit 1
    fi
    shift  $((OPTIND - 1))
        if [ -n "$1" ]; then
            if [ -z "$2" ]; then
                DEVICE=$1
                CREATE=false
                unset ARRAY
            else
                mapfile -t -d " " ARRAY < <(echo -n "${@}")
                DEVICE=${ARRAY[0]}
                CREATE=true
            fi
        fi
    ${LOGGING} && $NO_WARNING && exec < /dev/null > "${LOG}" 2>&1
    cleanup_structures
} # get_options ()

show ()
{
    if $SHOW; then
        show_var
        show_cleanup
        exit 0
    fi
} # show

set_raid_level ()
{
    [ -n "$VERBOSE" ] && echo "Set RAID start."
    if [ -n "${ARRAY[0]}" ]; then
        : "${SPARE:=$((${#ARRAY[@]}%2))}"
        if [ -z "$LEVEL" ] && [ $((${#ARRAY[@]} - SPARE)) -eq 2 ]; then
            LEVEL=mirror
        else
            : ${LEVEL:=raid10}
        fi
    fi

    case $LEVEL in
        1|raid1)
        LEVEL=mirror
        ;;
    esac
    if [ ${#ARRAY[@]} -lt 2 ] || [ "$LEVEL" = "mirror" ]; then
        STRIPE=false
    else
        STRIPE=true
    fi
    [ -n "$VERBOSE" ] && echo "Set RAID finish."
} # set_raid_level

check_utils ()
{
    [ -n "$VERBOSE" ] && echo "Check Utils start."
    UTILS="
    mdadm
    grub-install
    tar
    gawk
    cp
    debootstrap
    sfdisk
    basename
    dumpe2fs
    umount
    mount
    mkswap
    mkfs
    vgdisplay
    lvcreate
    vgcreate
    pvcreate
    parted
    yes
    partx
    sort
    pvremove
    pvs
    $APT
    dpkg
    free
    gawk
    pr
    xargs
    find
    chroot
    dialog
    mkdir
    vgs
    vgremove
    sipcalc
    "

    for prog in $UTILS; do
        type "$prog" > /dev/null 2>&1 ||
        MISSING="$MISSING $prog"
    done
    if [ -n "$MISSING" ]; then
        echo "
        $MISSING not found.
        You MUST have all of these utilities installed:
        "
        echo "$UTILS"
        echo "
        Exiting ...
        "
        exit
    fi

    [ -n "$VERBOSE" ] && echo "Check Utils finish."
} # check_utils

space_cutting ()
{
    ####################################
    ## CALCULATE DISK PARTITIONS SIZE ##
    ####################################
    [ -n "$VERBOSE" ] && echo "Space Cutting start."
    if $PARTITION; then
        if ! [ -b "$DEVICE" ]; then
            echo "There are no such block device $DEVICE". Exiting ...
            exit 2
        fi

        DISK=$(awk "{
            if (\"${DEVICE#/dev/}\" == \$NF) print int(\$(NF-1)/1024)
            }" /proc/partitions)

        $STRIPE && DISK=$((DISK*(${#ARRAY[@]}/2)))

        if [ -z "$DISK" ]; then
            echo "$DEVICE: no such device. Specify other one."
            exit
        fi

        RAM=$(free --mebi | gawk '/^Mem:/ {print $2}')
        case 0 in
            $([ "$RAM" -gt 4096 ]; echo $?))
            SWAP=4096
            ;;

            $([ "$RAM" -lt 2048 ]; echo $?))
            SWAP=2047
            ;;

            *)
            SWAP=$RAM
            ;;
        esac
        if ! $STRIPE; then
            RESERVE=$((DISK*RATE/100))
            [ $RESERVE -lt $LIMIT ] && RESERVE=$LIMIT
            EXTENT=$((DISK-RESERVE))
        else
            EXTENT=$((DISK-BOOT))
            :
        fi
        VOLUME=$((USR +
                    TMP +
                    ROOT +
                    SWAP +
                    home +
                    opt +
                    srv +
                    var))

        if [ $EXTENT -lt $VOLUME ]; then
            SWAP=10
            VOLUME=$((USR +
                        TMP +
                        ROOT +
                        SWAP +
                        home +
                        opt +
                        srv +
                        var))

        fi

        var=$((VOLUME -
                USR -
                ROOT -
                TMP -
                SWAP -
                home -
                opt -
                srv))


        # Check device if it is mdadm to install it,

        if mdadm --detail "$DEVICE" || [ ${#ARRAY[@]} -gt 1 ]; then
            MDADM="mdadm"
        fi

    fi # if $PARTITION; then
    [ -n "$VERBOSE" ] && echo "Space Cutting finish"
} # space_cutting ()

show_var ()
{
    ######################
    ## OUTPUT VARIABLES ##
    ######################

    echo " APT=$APT
    APT_OPTIONS=$APT_OPTIONS
    VERBOSE=$VERBOSE
    MIRROR=$MIRROR
    ARCH=$ARCH
    KERNEL=$KERNEL
    SUITE=$SUITE
    DEVICE=$DEVICE
    LEVEL=$LEVEL
    SPARE=$SPARE
    CREATE=$CREATE
    PARTITION=$PARTITION
    BOOT=$BOOT
    ROOT=$ROOT
    USR=$USR
    TMP=$TMP
    SWAP=$SWAP
    var=$var
    home=$home
    opt=$opt
    srv=$srv
    DISK=$DISK
    EXTENT=$EXTENT
    VOLUME=$VOLUME
    RESERVE=$RESERVE
    ADDRESS=${ADDRESS}
    METHOD=${METHOD}
    GATEWAY=${GATEWAY}
    NAMESERVER=${NAMESERVER}
    HOSTNAME=${HOSTNAME}
    DOMAIN=${DOMAIN}
    TIMEZONE=${TIMEZONE}
    LOG=$LOG " |
    pr --join-lines --width=78 --omit-header --columns=2 |
    gawk '{printf(" %-39s %-39s\n", $1, $2)}'
    echo " ARRAY=(${ARRAY[*]})"
} # show_var ()

chrooted_procs ()
{
    [ -n "$VERBOSE" ] && echo Remaining chrooted procs ...
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET \
        -exec file {} + 2>/dev/null |
    grep --extended-regexp "[0-9]" && [ $((--LOOP)) -gt 0 ]
}

umount_target ()
{
    [ -n "$VERBOSE" ] && echo "Umount Target start."
    LOOP=3
    [ -n "$VERBOSE" ] && echo Finding chrooted procs ...
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET \
        -exec file {} + 2>/dev/null
    find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET 2>/dev/null |
    grep --extended-regexp --only-matching "[0-9]+" |
    xargs --no-run-if-empty ps wwu
    while chrooted_procs; do
        [ -n "$VERBOSE" ] && echo Killing chrooted procs ...
        find /proc/[0-9]* -maxdepth 1 -name root -lname $TARGET 2>/dev/null |
        grep --extended-regexp --only-matching "[0-9]+" |
        if
            [ $((--LOOP)) -eq 1 ]
        then
            xargs --no-run-if-empty kill -9
        else
            xargs --no-run-if-empty kill
        fi
    done
    awk "/${TARGET//\//\\/}/ {print \$2}" /proc/mounts |
    sort --reverse |
    uniq |
    xargs --no-run-if-empty umount $VERBOSE --lazy
    [ -n "$VERBOSE" ] && echo "Umount Target finish."
} # umount_target ()

check_space ()
{
    [ -n "$VERBOSE" ] && echo "Check Space start."
    if [ $VOLUME -gt $EXTENT ] && $PARTITION; then
        echo "
        Disk is too small. Disk size should be more then $((VOLUME+RESERVE))
        Mb. Can not proceed. Adjust partition's size or do partitioning manual
        and use -p option.
        "
        show_var
        echo "
        Exiting ...
        "
        exit

    fi
    [ -n "$VERBOSE" ] && echo "Check Space finish."
} # check_space ()

show_cleanup ()
{
    [ -n "$ARRAY_DEVICES" ] &&
    echo "    These arrays will be destroyed:" $ARRAY_DEVICES
    [ -n "$ARRAY_MEMBERS" ] &&
    echo "    These arrays members will be zerroed:" $ARRAY_MEMBERS
    [ -n "$VGS" ] &&
    echo "    These volume groups will be removed:" $VGS
    [ -n "$PVS" ] &&
    echo "    These physical volumes will be removed:" $PVS
} # show_cleanup ()

cleanup_structures ()
{
    [ -n "$VERBOSE" ] &&
    echo "Figure out structures that include chosen disks"
    ARRAY_DEVICES="$( mdadm --detail --scan |
        awk '{print $2}'|
        while read -r MD; do
            mdadm --detail --export $MD |
            awk --field-separator = '/MD_DEVICE_dev_.*_DEV/ {print $2}'|
            while read -r MD_DEV; do
                for DEV in $DEVICE ${ARRAY[@]}; do
                    [ "${MD_DEV#$DEV}" != "$MD_DEV" ] &&
                    echo $(readlink --canonicalize $MD)
                done
            done
        done | sort | uniq)"
    [ -b $RAID ] && [ "${ARRAY_DEVICES/$RAID/}" == "$ARRAY_DEVICES" ] &&
    ARRAY_DEVICES="$ARRAY_DEVICES $RAID"
    [ -b $CORE ] && [ "${ARRAY_DEVICES/$CORE/}" == "$ARRAY_DEVICES" ] &&
    ARRAY_DEVICES="$ARRAY_DEVICES $CORE"

    ARRAY_MEMBERS="$( mdadm --detail --scan --export |
        awk --field-separator = '/MD_DEVICE_dev_.*_DEV/ {print $2}'|
        while read -r MD_DEV; do
            for DEV in $DEVICE ${ARRAY[@]}; do
                [ "${MD_DEV#$DEV}" != "$MD_DEV" ] &&
                echo $MD_DEV
            done
        done | sort | uniq)"

    VGS="$(pvs --noheadings -o pv_name,vg_name |
        while read -r PV VG; do
            for DEV in $DEVICE ${ARRAY[@]} $ARRAY_DEVICES; do
                [ "${PV#$DEV}" != "$PV" ] &&
                echo $VG
            done
        done | sort | uniq)"
    vgs $GROUP 2> /dev/null && [ "${VGS/$GROUP/}" == "$VGS" ] &&
    VGS="$VGS $GROUP"
    PVS="$(pvs --noheadings -o pv_name,vg_name |
        while read -r PV VG; do
            for DEV in $DEVICE ${ARRAY[@]} $ARRAY_DEVICES; do
                [ "${PV#$DEV}" != "$PV" ] &&
                echo $PV
            done
        done | sort | uniq)"

} # cleanup_structures ()

start_warning ()
{
    if ! $NO_WARNING; then
        WIDTH=${COLUMNS:=75}
        if [ -n "$VERBOSE" ]; then
            VARS="$(show_var)"
            HEIGHT=$(($(echo "$VARS" | wc -l)+17))
        else
            VARS=""
            HEIGHT=19
        fi
        dialog --colors --no-collapse --defaultno --yesno " \Zb\Z4Install \
            Debain GNU/Linux\Zn\ZB

$VARS

    \Zb\Z1WARNING!\Zn\ZB This will destroy all data on the hard disks:

    \Zr\Zb$(if [ ${#ARRAY[@]} -gt 1 ]; then echo "${ARRAY[@]}"; else \
        echo "$DEVICE"; fi)\ZB\ZR

$(show_cleanup)

    Are Your sure to continue?  " $HEIGHT $WIDTH || exit
        ${LOGGING} && exec < /dev/null >> "${LOG}" 2>&1
    fi
} # start_warning ()

start_head ()
{
    echo "
    Starting with parameters:
    "
    show_var

    echo "
    --=== Starting $(basename "$0") at $(date), elapsed $SECONDS seconds. ===--
    "
    [ -d $TARGET ] || mkdir $VERBOSE $TARGET
} # start_head ()

clean_space ()
{
    if "$PARTITION"; then
        [ -n "$VERBOSE" ] && echo "Clean Space start"

        umount_target
        invoke-rc.d lvm2 restart
        [ -n "$VERBOSE" ] && echo "Remove volume groups and volumes"
        [ -n "$VGS" ] &&
        vgremove $VERBOSE --yes --force --force $VGS
        [ -n "$VERBOSE" ] && echo "Remove physical volumes"
        [ -n "$PVS" ] &&
        pvremove $VERBOSE --yes --force --force $PVS
        # stop raid
        [ -n "$ARRAY_DEVICES" ] &&
        mdadm --stop $ARRAY_DEVICES
        [ -n "$VERBOSE" ] && echo "Remove raid members"
        [ -n "$ARRAY_MEMBERS" ] &&
        mdadm $VERBOSE --zero-superblock $ARRAY_MEMBERS
        [ -n "$VERBOSE" ] && echo "Remove partitions"
        for MEMBER in ${DEVICE} ${ARRAY[@]}; do
            partx --delete $MEMBER
            parted --script --machine $MEMBER mklabel gpt
            dd if=/dev/zero of=$MEMBER count=4
        done
    fi # if $PARTITION
    [ -n "$VERBOSE" ] && echo "Clean Space finish"
    [ "$ACTION" = "clean" ] && exit
} # clean_space ()

create_space ()
{
    #######################################################
    # PREPARE TARGET TO INSTALL TO: PARTITIONING IF NEED ##
    # AND CREATING FSTAB                                 ##
    #######################################################
    if $PARTITION; then
        ###############################
        ## PARTITIONING ENITIRE DISK ##
        ###############################
        # create single mirror array
        if ! $STRIPE; then
            if $CREATE; then
                echo yes |
                mdadm $VERBOSE  --create $CORE                         \
                                --level mirror                         \
                                --metadata=1.0                         \
                                --raid-devices=$((${#ARRAY[@]}-SPARE)) \
                                --spare-devices=$SPARE                 \
                                "${ARRAY[@]}"
                DEVICE=$CORE
            fi
            POOL=("$DEVICE")
        else
            mapfile -t -d " " POOL < <(echo -n "${ARRAY[@]}")
        fi
        PART="${DEVICE/$PART%*[0-9_]/${DEVICE}p}"

        ###############################################
        ## CALCULATE PARTITIONS BORDERS BY CYLINDERS ##
        ###############################################

        # partitioning
        for MEMBER in ${POOL[@]}; do
            [ -n "$VERBOSE" ] && echo Start partitioning  "$MEMBER"  ...
            if ! $STRIPE; then
                extent_end=$((BIOS+EFI+EXTENT-1))
                parted "$MEMBER"                                  \
                    mklabel gpt                                   \
                    unit MiB                                      \
                    mkpart primary ext2 1 $BIOS                   \
                    set 1 bios_grub on                            \
                    mkpart primary fat32 $BIOS $((BIOS+EFI))      \
                    mkpart primary ext2 $((BIOS+EFI)) $extent_end \
                    set 2 boot on                                 \
                    quit
            else
                parted --script "$MEMBER" mklabel gpt
                boot_end=$((BIOS+EFI+BOOT))
                extent_end=$(parted --script --machine $DEVICE unit MiB print |
                    awk --field-separator : -v NODE=$DEVICE '{
                        if ($1 == NODE) print gensub("MiB", "", 1, $2)-1
                        }')
                parted "$MEMBER"                                \
                    unit MiB                                    \
                    mkpart primary ext2 1 $BIOS                 \
                    set 1 bios_grub on                          \
                    mkpart primary fat32 $BIOS $((BIOS+EFI))    \
                    mkpart primary ext2 $((BIOS+EFI)) $boot_end \
                    set 2 boot on                               \
                    mkpart primary ext2 $boot_end $extent_end   \
                    quit
            fi
            [ -n "$VERBOSE" ] && echo Finish partitioning  "$MEMBER"  ...
        done # for MEMBER in ${POOL[@]}; do

        # create double raid arrays
        if $STRIPE && $CREATE; then
            echo yes |
            mdadm --create $CORE                         \
                  --level mirror                         \
                  --raid-devices $((${#ARRAY[@]}-SPARE)) \
                  --spare-devices $SPARE                 \
                  $(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\13/g')
            DEVICE=$CORE
            mdadm --create $RAID                         \
                  --level $LEVEL                         \
                  --raid-devices $((${#ARRAY[@]}-SPARE)) \
                  --spare-devices $SPARE                 \
                $(echo -n "${ARRAY[@]}" | sed 's/\([^ ]\+\)/\14/g')
        fi

        ############################
        ## CREATE LOGICAL VOLUMES ##
        ############################

        # If disk device name end with number (mdadm is case), then append 'p'
        # to further use it in partition device name.

        if ! $STRIPE; then
            sleep 2
            pvcreate --yes --force --force $VERBOSE ${PART}3 || exit
            vgcreate $VERBOSE $GROUP ${PART}3
            lvcreate $VERBOSE --yes --size ${BOOT} --name boot $GROUP
        else
            pvcreate --yes --force --force $VERBOSE $RAID || exit
            vgcreate $VERBOSE $GROUP $RAID
        fi
        lvcreate $VERBOSE --yes --size ${ROOT} --name $APEX $GROUP
        lvcreate $VERBOSE --yes --size ${USR} --name usr $GROUP
        lvcreate $VERBOSE --yes --size ${SWAP} --name swp $GROUP
        lvcreate $VERBOSE --yes --size ${TMP} --name tmp $GROUP

        for VOL in var home opt srv; do
            EXTENT=$(vgdisplay -c $GROUP | \
                gawk --field-separator : '{print $13*$16}')
            eval SIZE=\$${VOL}
            [ $((SIZE*1024)) -gt "$EXTENT" ] && SIZE=$((EXTENT/1024))
            [ $SIZE -gt 0 ] &&
            lvcreate $VERBOSE --yes --size ${SIZE} --name $VOL $GROUP
        done
        if ! $STRIPE; then
            mkfs.vfat $VERBOSE ${PART}2
        else
            mkfs $VERBOSE -L boot -t $FS_TYPE -F $CORE
        fi
        for POINT in /dev/"$GROUP"/*; do
            mkfs $VERBOSE -L "$(basename "$POINT")" -t $FS_TYPE -F "$POINT"
        done

        ######################################
        ## MOUNT ALL PARTITIONS AND VOLUMES ##
        ######################################
        ###################
        ## PREPARE FSTAB ##
        ###################

        # Add root (/) & boot records depends on raid level to fstab

        mkswap /dev/$GROUP/swp
        ROOT_DEVICE=/dev/$GROUP/$APEX
        mount $VERBOSE $ROOT_DEVICE "${TARGET}"
        FSTAB="proc /proc  proc defaults 0 0
        /dev/$GROUP/$APEX / $FS_TYPE defaults 0 1"
        for POINT in /dev/$GROUP/*; do
            LV=$(basename ${POINT})
            case $LV in
                $APEX|swp)
                continue
                ;;
            esac
            mkdir $VERBOSE "${TARGET}/$LV"
            mount $VERBOSE $POINT "${TARGET}/$LV"
            FSTAB="${FSTAB}
    $POINT /$LV $FS_TYPE defaults 0 2"
        done
        if $STRIPE; then
            mkdir $VERBOSE "${TARGET}/boot"
            mount $VERBOSE $VERBOSE $CORE "${TARGET}/boot"
            FSTAB="${FSTAB}
            $CORE /boot $FS_TYPE defaults 0 2"
        fi
        mkdir $VERBOSE "${TARGET}/boot/efi"
        FSTAB="${FSTAB}
        /dev/$GROUP/swp none swap sw 0 0
        ${PART}2 /boot/efi vfat defaults 0 2"
    else # if $PARTITION
        PART="${DEVICE/$PART%*[0-9_]/${DEVICE}p}"
        FSTAB="proc /proc  proc defaults 0 0 $(echo
        mount |
        gawk --assign TARGET=$TARGET '{
            if ($3 ~ TARGET) {
                gsub(TARGET,"", $3)
                "blkid --match-tag UUID --output value "$1"" | getline UUID
                if ($3 == "") {
                    gsub("","/",$3)
                    print "UUID="UUID, $3, $5, "defaults,errors=remount-ro 0 1"
                } else {
                    print "UUID="UUID, $3, $5, "defaults 0 2"
                }
            }
        }'
        # gawk '/partition/ {print $1, "none swap sw 0 0"}' /proc/swaps
        parted --script --machine $DEVICE print |
        awk --field-separator : --assign PART=$PART '/swap/ {
            print PART$1, "none swap sw 0 0"}'
        )"
        ROOT_DEVICE=$(
            awk --assign TARGET=$TARGET '{if ($2 == TARGET) print $1}' \
                /proc/mounts)
    fi # if $PARTITION
} # create_space ()

install_base_system ()
{
    FSTAB="${FSTAB}
    sysfs  /sys     sysfs    defaults                         0 0
    udev   /dev     devtmpfs defaults                         0 0
    devpts /dev/pts devpts   \
        rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0"

    #########################
    ## INSTALL BASE SYSTEM ##
    #########################

    [ -n "$VERBOSE" ] && echo "Installing Base System ..."
    if ! $DEBOOTSTRAP ${VERBOSE:+--verbose} "${BSOPT[@]}" --arch="$ARCH" \
        "$SUITE" $TARGET "$MIRROR"; then
        echo "Base System installation failed. Exiting ..."
        exit 3
    fi
    echo 'blacklist floppy' > $TARGET/etc/modprobe.d/blacklist-floppy.conf
} # install_base_system ()

configure_system ()
{
    ########################
    ## MAIN CONFIGURATION ##
    ########################

    echo "$FSTAB" |
    column --table > ${TARGET}/etc/fstab

    [ "$METHOD" = "static" ] &&
    STATIC="
        address $ADDRESS
        gateway $GATEWAY"
    echo "
    auto lo $IFACE

    iface lo inet loopback

    iface $IFACE inet $METHOD $STATIC
    " | sed 's/^    //'  > ${TARGET}/etc/network/interfaces

    echo "$HOSTNAME
    " > ${TARGET}/etc/hostname

    echo "
    127.0.0.1 localhost
    ${ADDRESS%/*} ${HOSTNAME}.${DOMAIN} ${HOSTNAME}
    " > ${TARGET}/etc/hosts

    echo "
    nameserver $NAMESERVER
    search $DOMAIN
    " |
    column --table > ${TARGET}/etc/resolv.conf

    echo "
    deb $MIRROR $SUITE main contrib non-free
    #deb $MIRROR unstable main contrib non-free
    #deb $MIRROR testing main contrib non-free
    #deb $MIRROR stable main contrib non-free
    " |
    column --table > ${TARGET}/etc/apt/sources.list

    cp $VERBOSE --archive ${TARGET}/etc/profile{,.dpkg-dist}

    echo "
    do_symlinks = No
    do_initrd = Yes
    do_bootloader = no
    postinst_hook = update-grub
    postrm_hook   = update-grub
    " |
    column --table > ${TARGET}/etc/kernel-img.conf

    echo "$TIMEZONE" > ${TARGET}/etc/timezone
    ln --symbolic --force $VERBOSE /usr/share/zoneinfo/"$TIMEZONE" \
        ${TARGET}/etc/localtime

} # configure_system ()

install_packages ()
{
    #########################################
    ## INSTALL AND CONFIGURE MAIN PACKAGES ##
    #########################################

    ATTACHMENTS="
    /etc/Muttrc.d/local.rc 644
    /etc/X11/Xresources/x11-local 644
    /etc/apt/apt.conf.d/cache 644
    /etc/grub.d/06_local_theme 755
    /etc/lynx/local.cfg 644
    /etc/network/inactive 600
    /etc/network/iptables 600
    /etc/systemd/system/iptables.service 644
    /etc/profile.d/local.sh 644
    /etc/skel/.lynxrc 644
    /etc/vim/vimrc.local 644
    /root/.muttrc 644
    /usr/lib/cgi-bin/quote 755
    /var/www/index.shtml 644"
    [ -n "$VERBOSE" ] && echo "
        Extracting attached files ...
    "
    echo "$ATTACHMENTS" | grep --invert-match '^$' |
    while read -r FILE MODE; do
        [ -d "$(dirname ${TARGET}"$FILE")" ] ||
        mkdir $VERBOSE --parents "$(dirname ${TARGET}"$FILE")"
        sed --expression="
            1,\%^###  BEGIN $FILE  ###$%d
            \%^###  END $FILE  ###$%,\$d
        " "$0" >> ${TARGET}"$FILE"
        chmod $VERBOSE "$MODE" ${TARGET}"$FILE"
        ls -l --directory ${TARGET}"$FILE"
    done
    if [ -e /sys/firmware/efi ]; then
        GRUB=grub-efi
    else
        GRUB=grub-pc
    fi

    # make udev db available in chroot for lvm used by grub
    mkdir $VERBOSE ${TARGET}/run/udev
    mount $VERBOSE --bind /run/udev ${TARGET}/run/udev

    chroot ${TARGET} su - <<-EOF
    eval  $DEBUG && set -x -v
    if ! [ -d /run/lock ]; then
        mkdir $VERBOSE --parents /run/lock
        chmod $VERBOSE ugo+wt /run/lock
    fi

    mount $VERBOSE /proc
    mount $VERBOSE /sys
    mount $VERBOSE /dev
    mount $VERBOSE /dev/pts
    [ -d /sys/firmware/efi/efivars ] &&
    mount $VERBOSE --types=efivarfs efivarfs /sys/firmware/efi/efivars

    MAIN_LIST="
    rsyslog
    grub-efi-amd64
    grub-pc-bin
    lvm2
    gawk
    parted
    dosfstools
    $MDADM
    sudo
    vim
    less
    mutt
    lynx
    ftp
    file
    lsof
    ssh
    screen
    exim4
    mailutils
    fortunes
    fortunes-ru
    host
    procinfo
    pciutils
    usbutils
    lsscsi
    scsitools
    ntp
    lsof
    ethtool
    mtr
    nmap
    lsb-release
    \$(apt-cache search ^firmware- | awk  '{print \$1}')
    bc
    man-db
    bash-completion
    wget
    iptables
    debconf-utils
    "

    # Set non-interactive mode
    export DEBIAN_FRONTEND="noninteractive"
    #export DEBIAN_NOWARNINGS="yes"
    #export DEBCONF_PRIORITY="critical"

    #echo -e \\\\t |
    $APT $APT_OPTIONS --yes update
    $APT $APT_OPTIONS --yes install \$MAIN_LIST
    $APT clean
    $APT $APT_OPTIONS --yes install linux-image-$KERNEL

    sed --in-place 's/^#DSHELL/DSHELL/' /etc/adduser.conf
    sed --in-place 's%^SHELL=/bin/sh%SHELL=/bin/bash%' /etc/default/useradd
    systemctl stop exim4
    systemctl stop ssh
    systemctl enable iptables

    echo "$HOSTNAME ALL=(ALL)NOPASSWD: ALL" >> /etc/sudoers

    ln $VERBOSE --symbolic /usr/games/fortune /usr/bin

    update-alternatives --set editor /usr/bin/vim.basic

    cp $VERBOSE -a /etc/Muttrc.d/colors.rc{,.dpkg-dist}
    sed --expression='s/^\([^#]\+\)/#\1/'                       \
        --expression='s/#.*\<color\>.*\<normal\>.*/color normal \
            default default/'                                   \
        --in-place /etc/Muttrc.d/colors.rc

    echo "# vim: filetype=muttrc:" >> /etc/Muttrc.d/colors.rc

    cp $VERBOSE --archive /etc/lynx/lynx.lss{,.dpkg-dist}
    sed --in-place 's/\\(^normal:\|^default:\\)/#\\1/' /etc/lynx/lynx.lss
    cp $VERBOSE --archive /etc/lynx/lynx.cfg{,.dpkg-dist}
    sed --in-place 's/^#\\(ENABLE_LYNXRC:\\)/\\1/' /etc/lynx/lynx.cfg
    sed --in-place 's/\(ENABLE_LYNXRC:.*\):OFF/\1:ON/' /etc/lynx/lynx.cfg

    cp $VERBOSE --archive /etc/locale.gen{,.dpkg-dist}
    sed --in-place 's/\(#\+\ \+\)\+\(ru_RU\|en_US\)/\2/' /etc/locale.gen
    locale-gen
    echo "LC_CTYPE=ru_RU.UTF-8" > /etc/default/locale

    cp $VERBOSE --archive /etc/screenrc{,.dpkg-dist}
    sed 's/^#\(startup_message[[:blank:]]\+off\)/\1/' -i /etc/screenrc
    echo "shell -bash" >> /etc/screenrc

    cp $VERBOSE --archive /etc/ssh/sshd_config{,.dpkg-dist}
    sed --expression='s/.*#.*\(ListenAddress[[:blank:]]\+0\.0\.0\.0\)/\1/' \
        --expression='s/^[^#]*\(ListenAddress[[:blank:]]\+::\)/#\1/' \
        --in-place /etc/ssh/sshd_config

    cd /etc/skel/
    cp $VERBOSE --archive .lynxrc /root
    cd
    echo "MAIL=/var/mail/$HOSTNAME" >> /root/.profile
    echo "root: $HOSTNAME" >> /etc/aliases

    LINUX_VERSION=\$(
    ls -1 --sort=version /boot/vmlinuz-* |
    tail -1 |
    sed 's/\/boot\/vmlinuz-//'
    )

    useradd --create-home --comment "System Administrator" $HOSTNAME
    echo -e  "$PASSWORD\n$PASSWORD" 2>&1|
    passwd $HOSTNAME
    passwd --lock root

    fortune | mail -s "First Mail" root
    fortune | mail -s "First Mail" $HOSTNAME

    echo "kernel.printk = 4 4 1 7" > /etc/sysctl.d/printk.conf

    if [ -f /etc/syslog.conf ]; then
        SYSLOG_CONF=/etc/syslog.conf
    else
        SYSLOG_CONF=/etc/rsyslog.conf
    fi
    cp $VERBOSE --archive \$SYSLOG_CONF{,.dpkg-dist}
    sed --in-place 's/\*\.\*/&;kern.!=warning/g' \$SYSLOG_CONF
    sed --in-place 's/kern\.\*/&;kern.!=warning/g' \$SYSLOG_CONF
    sed --in-place 's/\*\.=warn/&;kern.!=warning/g' \$SYSLOG_CONF
    sed --in-place 's/\*\.warn/&;kern.!=warning/g' \$SYSLOG_CONF
    echo 'kern.=warning  /var/log/kern.warning' >> \$SYSLOG_CONF

    cd /boot/grub
    wget --output-document=- \
    $BOOT_SPLASH/pool/main/g/grub2-splashimages/grub2-splashimages_*.tar.xz |
    tar --file=- --wildcards --strip-components=1 --extract --xz \
        --one-top-level=/usr/share/images/grub                   \
        grub2-splashimages-*/Lake_mapourika_NZ.tga
    cd -
    echo 'GRUB_BACKGROUND=/usr/share/images/grub/Lake_mapourika_NZ.tga
            ' > /etc/default/grub.d/background.cfg
    chmod 755 /etc/grub.d/06_local_theme
    sed 's/\(GRUB_CMDLINE_LINUX_DEFAULT=\)"\(.*\)quiet\(.*\)"/\1"\2 \3"/' \
        /etc/default/grub

    chmod $VERBOSE ugo+rx /usr/lib/cgi-bin/quote
EOF
} # install_packages ()

install_boot_loader ()
{
    # We should mount boot device in chroot environment to to install boot loader
    # Without sh it stopped at this point
    chroot ${TARGET} sh <<-EOB
    [ -n "$VERBOSE" ] && echo "Installing boot loader ..."
    SLEEP=10
    CYCLE=12

    [ -n "$MDADM" ] &&
    mdadm --detail $DEVICE &&
    while ! mdadm --detail $DEVICE |\
        grep --quiet "State : clean" && [ $((CYCLE--)) -gt 0 ]; do
        sleep \$SLEEP
        if [ \$CYCLE -lt 1 ]; then
            [ -n "$VERBOSE" ] && echo "Don't wait anymore for raid sync"
            mdadm --detail $DEVICE | grep "State :"
        fi
    done
    if ! $STRIPE; then
        [ -n "$MDADM" ] &&
        mdadm --detail $DEVICE &&
        echo "(hd0) $DEVICE" > /boot/grub/device.map
        if $PARTITION; then
            mount $VERBOSE ${PART}2 /boot/efi
        fi
        grub-install --target=x86_64-efi $DEVICE
        grub-install --target=i386-pc $DEVICE
        mkdir $VERBOSE /boot/efi/EFI/boot
        cp $VERBOSE /boot/efi/EFI/debian/grubx64.efi \
                    /boot/efi/EFI/boot/bootx64.efi
        CONF="configfile (lvm/sys-boot)/grub/grub.cfg"
        echo $CONF > /boot/efi/EFI/boot/grub.cfg
        sfdisk $DEVICE --part-type 2 "EFI System"
        sfdisk $DEVICE --part-type 3 "Linux LVM"
    else
        echo "#!/bin/bash
        for MEMBER in ${ARRAY[@]}; do
            umount $VERBOSE /boot/efi
            mkfs.vfat $VERBOSE \\\${MEMBER}2
            mount $VERBOSE \\\${MEMBER}2 /boot/efi
            grub-install.bin --target=i386-pc \\\${MEMBER}
            grub-install.bin --target=x86_64-efi \\\${MEMBER}
            if [ -e /sys/firmware/efi ]; then
                efibootmgr --verbose | gawk \"/\\\$(
                    blkid --match-tag PARTUUID --output value \\\${MEMBER}2)/ {
                    print(gensub(\\\\\"Boot([[:xdigit:]]{4})\\\\\\\\\*\\\\\",
                        \\\\\"\\\\\\\\\1\\\\\", \\\\\"g\\\\\", \\\\\\\$1))}\" |
                while read BOOTNUM; do
                    efibootmgr --bootnum \\\${BOOTNUM} --delete-bootnum
                done
                efibootmgr --disk \\\$MEMBER                    \\\\
                    --create --loader EFI/debian/grubx64.efi \\\\
                    --part 2 --label \"Debian(\\\$MEMBER)\"
            fi
            mkdir $VERBOSE /boot/efi/EFI/boot
            cp --archive --verbose /boot/efi/EFI/*/grubx64.efi \\\\
                /boot/efi/EFI/boot/bootx64.efi
            CONF=\"configfile (lvm/$GROUP-boot)/grub/grub.cfg\"
            echo \\\$CONF > /boot/efi/EFI/boot/grub.cfg
        done
        " > /usr/sbin/grub-install.sh
        sed --in-place --expression="s/\t/    /g" -re "s/^ {8}//" \\
            /usr/sbin/grub-install.sh
        chmod $VERBOSE +x /usr/sbin/grub-install.sh
        dpkg-divert --local --divert /usr/sbin/grub-install.bin \
            --add /usr/sbin/grub-install
        cd /usr/sbin
        mv $VERBOSE grub-install grub-install.bin
        ln $VERBOSE --symbolic grub-install.sh grub-install
        grub-install

    fi
    sed --in-place '/GRUB_CMDLINE_LINUX_DEFAULT/s/quiet//' /etc/default/grub
    update-grub
EOB
} # install_boot_loader ()

save_install_list ()
{
    [ -d /etc/install-debian/install ] &&
    tar --create --file - $VERBOSE --directory=/etc/install-debian/install . |
    tar --extract --file - --directory=$TARGET
} # save_install_list ()

finish_foot ()
{
    echo "
    --=== Finish $(basename "$0") at $(date), elapsed $SECONDS seconds. ===--
    "
} # finish_foot ()

save_log ()
{
    [ -f "$LOG" ] &&
    cp --archive "$LOG" $TARGET/root
    umount_target
} # save_log ()

send_password ()
{
    #############################
    ## SEND LOGIN AND PASSWORD ##
    #############################

    echo "
    System Administrator account:
        Login:     $HOSTNAME
        Password:  $PASSWORD

    Change password just after login!

    Root account blocked. Type to become root:
        sudo su -

    "
} # send_password ()

init_variables
get_options "$@"
$DEBUG && set -x -v
set_raid_level
check_utils
space_cutting
check_space
show
start_warning
clean_space
start_head
create_space
install_base_system
configure_system
install_packages
install_boot_loader
save_install_list
finish_foot
save_log
send_password
exit $?

cat > /dev/null <<EOT
###  BEGIN /etc/profile.d/local.sh  ###
#
export EDITOR=vim
export HOSTNAME
alias ls='ls'
[ $(id -u) -gt 0 ] && umask g+w
###  END /etc/profile.d/local.sh  ###

###  BEGIN /etc/vim/vimrc.local  ###
syntax enable
set background=dark
set autoindent
set nobackup
set nowritebackup
set backupcopy=no
set termencoding=utf-8
set fileencoding=utf-8
set modeline
set sw=4
set ts=4
set expandtab
set nois
###  END /etc/vim/vimrc.local  ###

###  BEGIN /etc/Muttrc.d/local.rc  ###
ignore *
unignore From: To: Cc: Subject: Date:
auto_view text/html
bind pager $ bottom
set mbox=~/Mail/inbox
set record=~/Mail/sent
set use_from
set envelope_from
set editor="vim \'+set tw=72\'"
set pager_stop
set charset=utf-8
set allow_8bit=yes
set send_charset=utf-8
set rfc2047_parameters
set ascii_chars=yes
set meta_key=no
# vim: filetype=muttrc:
###  END /etc/Muttrc.d/local.rc  ###

###  BEGIN /etc/skel/.lynxrc  ###
accept_all_cookies=on
raw_mode=on
force_cookie_prompt=yes
force_ssl_prompt=yes
ftp_passive=on
set_cookies=on
show_color=never
user_mode=ADVANCED
verbose_images=off
make_pseudo_alts_for_inlines=off
###  END /etc/skel/.lynxrc  ###

###  BEGIN /etc/lynx/local.cfg  ###
STARTFILE:/dev/null
# vim: filetype=lynx:
###  END /etc/lynx/local.cfg  ###

###  BEGIN /etc/network/iptables  ###
#
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]

--append INPUT ! --in-interface $IFACE --match state --state NEW --jump ACCEPT
--append INPUT --match conntrack --ctstate RELATED,ESTABLISHED --jump ACCEPT
--append INPUT --protocol tcp --match tcp --dport 22 --jump ACCEPT
--append INPUT --protocol icmp --jump ACCEPT
COMMIT

*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

###  END /etc/network/iptables  ###

###  BEGIN /etc/systemd/system/iptables.service  ###
[Unit]
Description=iptables

[Service]
ExecStart=iptables-restore --noflush /etc/network/iptables

[Install]
WantedBy=network-online.target
###  END /etc/systemd/system/iptables.service  ###

###  BEGIN /etc/network/inactive  ###
#
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT

###  END /etc/network/inactive  ###

###  BEGIN /etc/apt/apt.conf.d/cache  ###
APT::Cache::AllVersions false;
APT::Cache-Limit 0x3000000;
###  END /etc/apt/apt.conf.d/cache  ###

###  BEGIN /etc/grub.d/06_local_theme  ###
#!/bin/bash
echo set color_normal=yellow/black
###  END /etc/grub.d/06_local_theme  ###

###  BEGIN /usr/lib/cgi-bin/quote  ###
#!/bin/bash

LC_CTYPE="ru_RU.UTF-8"
export LC_CTYPE
echo "Content-Type: text/html; charset=utf-8

<html>
<head>
    <title>
    $(fortune -sn 60 ru .)
    </title>
</head>
<body>
    <center>
    <h2><big>
    <a href="">$(fortune -sn 60 ru .)</a>
    <br>
    </big></h2>
"
fortune ru . | sed 's/$/\<br\>/'
echo "
    </center>
</body>
</html>
"
###  END /usr/lib/cgi-bin/quote  ###

###  BEGIN /var/www/index.shtml  ###
    <!--#include virtual="/cgi-bin/quote" -->
###  END /var/www/index.shtml  ###

###  BEGIN /etc/X11/Xresources/x11-local  ###
! \$Id$
URxvt.background: DarkSlateGray
URxvt.foreground: Wheat
URxvt.geometry: 100x45
! URxvt.font: 10x20
! URxvt.font: 9x15
URxvt.font: xft:Mono
URxvt.loginShell: true
URxvt.scrollBar: false
XLock.font: -sony-fixed-medium-r-*-*-24-*-*-*-*-*-*
###  END /etc/X11/Xresources/x11-local  ###

###  BEGIN /root/.muttrc  ###
set folder = /home/$HOSTNAME/Mail
set mbox=\$folder/inbox
set record=\$folder/sent
###  END /root/.muttrc  ###

###  BEGIN   ###
###  END   ###
EOT
